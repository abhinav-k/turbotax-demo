export declare class Tag<T> {
    private __$$unique_name$$__;
}
export declare type Tagged<T, U> = T & Tag<U>;
export declare type StrKeyOf<T> = Extract<keyof T, string>;
export declare type AnyFunction = (...args: any) => any;
export declare type Initializer<T> = T extends Function ? never : T | (() => T);
export declare type Initializer1<A, T = A> = T extends Function ? never : T | ((arg: A) => T);
export declare type ValueOrFunction<T> = T extends Function ? (value: T) => T : T | ((value: T) => T);
export declare type PromiseType<T> = T | PromiseLike<T>;
export declare type UnwrapPromise<T> = T extends PromiseLike<infer R> ? UnwrapPromise<R> : T;
export declare type Overwrite<A, B> = Omit<A, keyof B> & B;
declare type Primitive = undefined | null | boolean | string | number | Function | Date | RegExp;
declare type NotPlainObject = Primitive | ReadonlyArray<any> | ReadonlySet<any> | ReadonlyMap<any, any>;
export declare type DeepReadonly<T> = T extends Primitive ? T : T extends Map<infer K, infer V> ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>> : T extends Set<infer T> ? ReadonlySet<DeepReadonly<T>> : {
    readonly [P in keyof T]: DeepReadonly<T[P]>;
};
export declare type ArrayItem<T> = T extends ReadonlyArray<infer U> ? U : never;
export declare type DeepPartial<T> = T extends NotPlainObject ? T : {
    [P in keyof T]?: T[P] extends NotPlainObject ? T[P] : DeepPartial<T[P]>;
};
export {};
