import { PromiseType } from "./types";
export declare const toPromise: <T>(fn: () => PromiseType<T>) => Promise<T>;
export declare type Deferred<T> = Promise<T> & {
    resolve(x: PromiseType<T>): Promise<T>;
    reject(error: any): Promise<never>;
};
export declare const deferred: <T = void>() => Deferred<T>;
export declare const debounced: <T, A extends any[] = []>(fn: (...args: A) => PromiseType<T>, ms: number) => (...args: A) => Promise<T>;
export declare const throttled: <T, A extends any[] = []>(fn: (...args: A) => PromiseType<T>, ms: number) => (...args: A) => Promise<T>;
export declare const sleep: (ms: number) => Promise<void>;
export declare function delayed<A extends unknown[], T>(fn: (...args: A) => T, ms: number): (...args: A) => Promise<T>;
export declare function immediate<T extends Function>(fn: T): T;
export declare const disposable: (...fns: Function[]) => () => void;
export declare function g<T>(x: PromiseType<T>): Generator<unknown, T>;
declare type Cancellable = {
    readonly isCancelled: boolean;
    cancel(): void;
};
export declare type Flow<T> = Promise<T> & {
    cancel(): void;
};
export declare const runStep: (g: Generator, arg: any, isError: boolean) => IteratorResult<unknown, any>;
export declare function flow<T>(this: any, fn: (ctx: Cancellable) => Generator<any, T>, run?: (g: Generator<unknown, any, unknown>, arg: any, isError: boolean) => IteratorResult<unknown, any>): Flow<T>;
export declare function pLimited<A extends unknown[] = any, T = any>(fn: (...args: A) => Promise<T>, limit: number): (...args: A) => Promise<T>;
export declare function cancellable(fn: (checkCancelled: <T>(x: T) => T) => any, onCancel?: () => void): () => void;
export {};
