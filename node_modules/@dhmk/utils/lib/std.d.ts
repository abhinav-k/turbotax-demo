import { StrKeyOf, DeepReadonly, DeepPartial } from "./types";
export declare const noop: () => void;
export declare const id: <T>(x: T) => T;
export declare const range: (count: number, start?: number) => number[];
export declare const arraysEqual: <T>(a: readonly T[], b: readonly T[]) => boolean;
export declare const shallowEqual: (a: object, b: object) => boolean;
export declare function objectFrom<V, K extends keyof any = keyof any>(entries: Iterable<[K, V]>): Record<K, V>;
declare type ValueMapper<T, R = any> = (v: T[StrKeyOf<T>], k: StrKeyOf<T>, src: T) => R;
declare type KeyMapper<T, R = any> = (k: StrKeyOf<T>, v: T[StrKeyOf<T>], src: T) => R;
export declare function objectMap<T extends object, V extends ValueMapper<T>>(src: T, mapValue: V): Record<StrKeyOf<T>, ReturnType<V>>;
export declare function objectMap<T extends object>(src: T, mapValue: ValueMapper<T>, mapKey?: KeyMapper<T>): any;
export declare function objectTransform<T, K extends keyof any = keyof T, V = T[keyof T]>(src: T, mapEntry: (v: T[keyof T], k: keyof T, src: T) => readonly [K, V] | null): Record<K, V>;
export declare function getter<T>(t: T, k: keyof T): Readonly<{
    use<R>(value: R): R;
}>;
export declare function getter<T, R>(t: T, k: keyof T, value: R): R;
export declare function createFactory<T extends abstract new (...args: any[]) => any>(c: T): (...args: ConstructorParameters<T>) => InstanceType<T>;
export declare function createFactoryAs<A>(): <T extends abstract new (...args: any[]) => any>(c: T) => (...args: ConstructorParameters<T>) => A;
export declare const call: <T>(fn: () => T) => T;
export declare const deepReadonly: <T>(x: T) => DeepReadonly<T>;
declare type Merge = {
    <T>(a: T, b: Partial<T>): T;
    <T, P = Partial<T>>(b: P): (a: T) => T;
};
export declare const merge: Merge;
declare type MergeDeep = {
    <T>(a: T, b: DeepPartial<T>): T;
    <T, P = DeepPartial<T>>(b: P): (a: T) => T;
};
export declare const mergeDeep: MergeDeep;
export declare const join: <A extends string, B extends string, S extends string>(a: A, sep: S, b: B) => `${A}${S}${B}`;
export declare const namespace: <S extends string>(s: S) => <SS extends string>(suffix: SS) => `${S}/${SS}`;
export declare function assert(condition: any, msg?: string): asserts condition;
export declare const isPlainObject: (x: any) => x is object;
export declare function flatMap<T, R>(src: ReadonlyArray<T>, fn: (item: T, index: number) => ReadonlyArray<R>): R[];
export {};
