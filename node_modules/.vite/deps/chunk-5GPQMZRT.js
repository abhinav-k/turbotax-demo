import {
  __commonJS
} from "./chunk-DSTXS4JB.js";

// node_modules/@yext/components-tsx-geo/dist/constants.js
var require_constants = __commonJS({
  "node_modules/@yext/components-tsx-geo/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EARTH_RADIUS_KILOMETERS = exports.EARTH_RADIUS_MILES = exports.Projection = exports.Unit = void 0;
    var Unit = Object.freeze({
      DEGREE: Symbol("deg"),
      KILOMETER: Symbol("km"),
      MILE: Symbol("mi"),
      RADIAN: Symbol("r")
    });
    exports.Unit = Unit;
    var Projection = Object.freeze({
      MERCATOR: Symbol("mercator"),
      SPHERICAL: Symbol("spherical")
    });
    exports.Projection = Projection;
    var EARTH_RADIUS_MILES = 3959;
    exports.EARTH_RADIUS_MILES = EARTH_RADIUS_MILES;
    var EARTH_RADIUS_KILOMETERS = 6371;
    exports.EARTH_RADIUS_KILOMETERS = EARTH_RADIUS_KILOMETERS;
  }
});

// node_modules/@yext/components-tsx-geo/dist/Coordinate.js
var require_Coordinate = __commonJS({
  "node_modules/@yext/components-tsx-geo/dist/Coordinate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Coordinate = void 0;
    var constants_js_1 = require_constants();
    var LATITUDE_ALIASES = ["latitude", "lat"];
    var LONGITUDE_ALIASES = ["longitude", "lon", "lng", "long"];
    function findValue(object, keys) {
      for (const key of keys) {
        if (object[key] || object[key] === 0) {
          return object[key];
        }
      }
    }
    function forceNumber(value) {
      switch (typeof value) {
        case "string":
        case "number":
          const parsed = Number.parseFloat(value);
          if (Number.isNaN(parsed)) {
            throw new Error(`'${value}' must be convertible to a Number'`);
          }
          return parsed;
        default:
          throw new Error(`typeof '${value}' must be a number or a string that can be converted to a number, is '${typeof value}'`);
      }
    }
    function degreesToRadians(degrees) {
      return degrees * Math.PI / 180;
    }
    function radiansToDegrees(radians) {
      return radians / Math.PI * 180;
    }
    function haversineDistance(source, dest) {
      const lat1Rads = degreesToRadians(source.latitude);
      const lat2Rads = degreesToRadians(dest.latitude);
      const deltaLat = lat2Rads - lat1Rads;
      const deltaLon = degreesToRadians(dest.longitude - source.longitude);
      const a = Math.pow(Math.sin(deltaLat / 2), 2) + Math.cos(lat1Rads) * Math.cos(lat2Rads) * Math.pow(Math.sin(deltaLon / 2), 2);
      return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    function mercatorLatDistanceInRadians(latitudeA, latitudeB) {
      const aTan = Math.tan(Math.PI / 360 * (latitudeA + 90));
      const bTan = Math.tan(Math.PI / 360 * (latitudeB + 90));
      return Math.log(bTan / aTan);
    }
    function mercatorLatAddRadians(startingLat, radians) {
      const aTan = Math.tan(Math.PI / 360 * (startingLat + 90));
      const bTan = aTan * Math.pow(Math.E, radians);
      return Math.atan(bTan) * 360 / Math.PI - 90;
    }
    var Coordinate = class {
      constructor(latitudeOrObject, longitude) {
        let latitude = latitudeOrObject;
        if (typeof latitudeOrObject == "object") {
          latitude = findValue(latitudeOrObject, LATITUDE_ALIASES);
          longitude = findValue(latitudeOrObject, LONGITUDE_ALIASES);
          latitude = typeof latitude == "function" ? latitude() : latitude;
          longitude = typeof longitude == "function" ? longitude() : longitude;
        }
        this.latitude = latitude;
        this.longitude = longitude;
      }
      get latitude() {
        return this._lat;
      }
      get longitude() {
        return this._lon;
      }
      get normalLon() {
        return ((this._lon + 180) % 360 + 360) % 360 - 180;
      }
      set latitude(newLat) {
        this._lat = Math.max(-90, Math.min(forceNumber(newLat), 90));
      }
      set longitude(newLon) {
        this._lon = forceNumber(newLon);
      }
      add(latDist, lonDist, unit = constants_js_1.Unit.DEGREE, projection = constants_js_1.Projection.SPHERICAL) {
        if (projection == constants_js_1.Projection.MERCATOR && (unit == constants_js_1.Unit.DEGREE || unit == constants_js_1.Unit.RADIAN)) {
          const latDistRad = unit == constants_js_1.Unit.DEGREE ? degreesToRadians(latDist) : latDist;
          const lonDistDeg = unit == constants_js_1.Unit.DEGREE ? lonDist : radiansToDegrees(lonDist);
          this.latitude = mercatorLatAddRadians(this.latitude, latDistRad);
          this.longitude += lonDistDeg;
        } else {
          switch (unit) {
            case constants_js_1.Unit.DEGREE:
              this.latitude += latDist;
              this.longitude += lonDist;
              break;
            case constants_js_1.Unit.KILOMETER:
              this.latitude += radiansToDegrees(latDist) * constants_js_1.EARTH_RADIUS_KILOMETERS;
              this.longitude += radiansToDegrees(lonDist) * constants_js_1.EARTH_RADIUS_KILOMETERS * Math.cos(degreesToRadians(this.latitude));
              break;
            case constants_js_1.Unit.MILE:
              this.latitude += radiansToDegrees(latDist) * constants_js_1.EARTH_RADIUS_MILES;
              this.longitude += radiansToDegrees(lonDist) * constants_js_1.EARTH_RADIUS_MILES * Math.cos(degreesToRadians(this.latitude));
              break;
            case constants_js_1.Unit.RADIAN:
              this.latitude += radiansToDegrees(latDist);
              this.longitude += radiansToDegrees(lonDist);
              break;
          }
        }
      }
      distanceTo(coordinate, unit = constants_js_1.Unit.MILE, projection = constants_js_1.Projection.SPHERICAL) {
        if (projection == constants_js_1.Projection.MERCATOR && (unit == constants_js_1.Unit.DEGREE || unit == constants_js_1.Unit.RADIAN)) {
          const latDist = mercatorLatDistanceInRadians(this.latitude, coordinate.latitude);
          const absoluteLonDist = Math.abs(coordinate.normalLon - this.normalLon);
          const lonDist = degreesToRadians(Math.min(absoluteLonDist, 360 - absoluteLonDist));
          const radianDist = Math.sqrt(Math.pow(latDist, 2) + Math.pow(lonDist, 2));
          switch (unit) {
            case constants_js_1.Unit.DEGREE:
              return radiansToDegrees(radianDist);
            case constants_js_1.Unit.RADIAN:
              return radianDist;
          }
        } else {
          const radianDist = haversineDistance(this, coordinate);
          switch (unit) {
            case constants_js_1.Unit.DEGREE:
              return radiansToDegrees(radianDist);
            case constants_js_1.Unit.KILOMETER:
              return radianDist * constants_js_1.EARTH_RADIUS_KILOMETERS;
            case constants_js_1.Unit.MILE:
              return radianDist * constants_js_1.EARTH_RADIUS_MILES;
            case constants_js_1.Unit.RADIAN:
              return radianDist;
          }
        }
      }
      equals(coordinate) {
        return coordinate && coordinate.latitude === this.latitude && coordinate.longitude === this.longitude;
      }
      searchQueryString() {
        return `${this.latitude},${this.longitude}`;
      }
    };
    exports.Coordinate = Coordinate;
  }
});

// node_modules/@yext/components-tsx-geo/dist/GeoBounds.js
var require_GeoBounds = __commonJS({
  "node_modules/@yext/components-tsx-geo/dist/GeoBounds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GeoBounds = void 0;
    var constants_js_1 = require_constants();
    var Coordinate_js_1 = require_Coordinate();
    var GeoBounds = class {
      static fit(coordinates) {
        const latitudes = coordinates.map((coordinate) => coordinate.latitude);
        const north = Math.max(...latitudes);
        const south = Math.min(...latitudes);
        const longitudes = coordinates.map((coordinate) => coordinate.normalLon).sort((i, j) => i - j);
        const splitIndex = longitudes.map((longitude, i) => {
          const next = i < longitudes.length - 1 ? longitudes[i + 1] : longitudes[0] + 360;
          return { distance: next - longitude, index: i };
        }).reduce((max, distance) => distance.distance > max.distance ? distance : max).index;
        const east = longitudes[splitIndex];
        const west = longitudes[(splitIndex + 1) % longitudes.length];
        return new this(new Coordinate_js_1.Coordinate(south, west), new Coordinate_js_1.Coordinate(north, east));
      }
      constructor(sw, ne) {
        this._ne = new Coordinate_js_1.Coordinate(ne);
        this._sw = new Coordinate_js_1.Coordinate(sw);
      }
      get ne() {
        return this._ne;
      }
      get sw() {
        return this._sw;
      }
      set ne(newNE) {
        this._ne = new Coordinate_js_1.Coordinate(newNE);
      }
      set sw(newSW) {
        this._sw = new Coordinate_js_1.Coordinate(newSW);
      }
      contains(coordinate) {
        const withinLatitude = this._sw.latitude <= coordinate.latitude && coordinate.latitude <= this._ne.latitude;
        const longitudeSpansGlobe = this._ne.longitude - this._sw.longitude >= 360;
        const withinNormalLon = this._sw.normalLon <= this._ne.normalLon ? this._sw.normalLon <= coordinate.normalLon && coordinate.normalLon <= this._ne.normalLon : this._sw.normalLon <= coordinate.normalLon || coordinate.normalLon <= this._ne.normalLon;
        return withinLatitude && (longitudeSpansGlobe || withinNormalLon);
      }
      extend(coordinate) {
        this._ne.latitude = Math.max(this._ne.latitude, coordinate.latitude);
        this._sw.latitude = Math.min(this._sw.latitude, coordinate.latitude);
        if (!this.contains(coordinate)) {
          const eastDist = ((coordinate.longitude - this._ne.longitude) % 360 + 360) % 360;
          const westDist = ((this._sw.longitude - coordinate.longitude) % 360 + 360) % 360;
          if (eastDist < westDist) {
            this._ne.longitude += eastDist;
          } else {
            this._sw.longitude -= westDist;
          }
        }
      }
      getCenter(projection = constants_js_1.Projection.SPHERICAL) {
        const nw = new Coordinate_js_1.Coordinate(this._ne.latitude, this._sw.longitude);
        const latDist = this._sw.distanceTo(nw, constants_js_1.Unit.DEGREE, projection);
        const newLon = (nw.longitude + this._ne.longitude) / 2 + (this._ne.longitude < nw.longitude ? 180 : 0);
        nw.add(-latDist / 2, 0, constants_js_1.Unit.DEGREE, projection);
        nw.longitude = newLon;
        return nw;
      }
    };
    exports.GeoBounds = GeoBounds;
  }
});

// node_modules/@yext/components-tsx-geo/dist/index.js
var require_dist = __commonJS({
  "node_modules/@yext/components-tsx-geo/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_constants(), exports);
    __exportStar(require_Coordinate(), exports);
    __exportStar(require_GeoBounds(), exports);
  }
});

// node_modules/@yext/components-tsx-maps/dist/util/Assertions.js
var require_Assertions = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/util/Assertions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertInstance = exports.assertType = exports.Type = void 0;
    var Type = {
      UNDEFINED: "undefined",
      NULL: "object",
      BOOLEAN: "boolean",
      NUMBER: "number",
      BIGINT: "bigint",
      STRING: "string",
      SYMBOL: "symbol",
      FUNCTION: "function",
      OBJECT: "object"
    };
    exports.Type = Type;
    function assertType(object, type) {
      if (typeof type != "string") {
        throw new Error("Assertion error: 'type' must be a string");
      }
      if (typeof object !== type) {
        throw new Error(`Expected an object of type '${type}' but received '${typeof object}'`);
      }
    }
    exports.assertType = assertType;
    function assertInstance(object, instanceClass) {
      let isInstance;
      try {
        isInstance = object instanceof instanceClass;
      } catch (err) {
        throw new Error("Assertion error: 'instanceClass' is not a valid constructor");
      }
      if (!isInstance) {
        throw new Error(`Expected an instance of '${instanceClass.name}' but received '${object.constructor.name}'`);
      }
    }
    exports.assertInstance = assertInstance;
  }
});

// node_modules/@yext/components-tsx-maps/dist/ProviderMap.js
var require_ProviderMap = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/ProviderMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProviderMap = exports.ProviderMapOptions = void 0;
    var Assertions_js_1 = require_Assertions();
    var MapProvider_js_1 = require_MapProvider();
    var ProviderMapOptions = class {
      constructor(provider, wrapper) {
        (0, Assertions_js_1.assertInstance)(provider, MapProvider_js_1.MapProvider);
        (0, Assertions_js_1.assertInstance)(wrapper, HTMLElement);
        this.providerMapClass = provider.getMapClass();
        this.wrapper = wrapper;
        this.controlEnabled = true;
        this.panHandler = () => {
        };
        this.panStartHandler = () => {
        };
        this.providerOptions = {};
      }
      withControlEnabled(controlEnabled) {
        this.controlEnabled = controlEnabled;
        return this;
      }
      withPanHandler(panHandler) {
        (0, Assertions_js_1.assertType)(panHandler, Assertions_js_1.Type.FUNCTION);
        this.panHandler = panHandler;
        return this;
      }
      withPanStartHandler(panStartHandler) {
        (0, Assertions_js_1.assertType)(panStartHandler, Assertions_js_1.Type.FUNCTION);
        this.panStartHandler = panStartHandler;
        return this;
      }
      withProviderOptions(providerOptions) {
        this.providerOptions = providerOptions;
        return this;
      }
      build() {
        const providerMapClass = this.providerMapClass;
        return new providerMapClass(this);
      }
    };
    exports.ProviderMapOptions = ProviderMapOptions;
    var ProviderMap = class {
      constructor(options) {
        (0, Assertions_js_1.assertInstance)(options, ProviderMapOptions);
        this._panHandler = options.panHandler;
        this._panStartHandler = options.panStartHandler;
      }
      getCenter() {
        throw new Error("not implemented");
      }
      getZoom() {
        throw new Error("not implemented");
      }
      setCenter(coordinate, animated) {
        throw new Error("not implemented");
      }
      setZoom(zoom, animated) {
        throw new Error("not implemented");
      }
      setZoomCenter(zoom, center, animated) {
        this.setZoom(zoom, animated);
        this.setCenter(center, animated);
      }
    };
    exports.ProviderMap = ProviderMap;
  }
});

// node_modules/@yext/components-tsx-maps/dist/ProviderPin.js
var require_ProviderPin = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/ProviderPin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HTMLProviderPin = exports.ProviderPin = exports.ProviderPinOptions = void 0;
    var Assertions_js_1 = require_Assertions();
    var MapProvider_js_1 = require_MapProvider();
    var ProviderPinOptions = class {
      constructor(provider) {
        (0, Assertions_js_1.assertInstance)(provider, MapProvider_js_1.MapProvider);
        this.providerPinClass = provider.getPinClass();
        this.clickHandler = () => {
        };
        this.focusHandler = (focused) => {
        };
        this.hoverHandler = (hovered) => {
        };
        this.icons = {};
      }
      withClickHandler(clickHandler) {
        (0, Assertions_js_1.assertType)(clickHandler, Assertions_js_1.Type.FUNCTION);
        this.clickHandler = clickHandler;
        return this;
      }
      withFocusHandler(focusHandler) {
        (0, Assertions_js_1.assertType)(focusHandler, Assertions_js_1.Type.FUNCTION);
        this.focusHandler = focusHandler;
        return this;
      }
      withHoverHandler(hoverHandler) {
        (0, Assertions_js_1.assertType)(hoverHandler, Assertions_js_1.Type.FUNCTION);
        this.hoverHandler = hoverHandler;
        return this;
      }
      withIcons(icons) {
        this.icons = icons;
        return this;
      }
      build() {
        const providerPinClass = this.providerPinClass;
        return new providerPinClass(this);
      }
    };
    exports.ProviderPinOptions = ProviderPinOptions;
    var ProviderPin = class {
      constructor(options) {
        (0, Assertions_js_1.assertInstance)(options, ProviderPinOptions);
        this._clickHandler = options.clickHandler;
        this._focusHandler = options.focusHandler;
        this._hoverHandler = options.hoverHandler;
        this._icons = options.icons;
      }
      setCoordinate(coordinate) {
        throw new Error("not implemented");
      }
      setMap(newMap, currentMap) {
        throw new Error("not implemented");
      }
      setProperties(pinProperties) {
        throw new Error("not implemented");
      }
    };
    exports.ProviderPin = ProviderPin;
    var htmlPinBaseStyle = Object.freeze({
      backgroundPosition: "center",
      backgroundRepeat: "no-repeat",
      backgroundSize: "contain",
      left: "0",
      outline: "none",
      pointerEvents: "auto",
      position: "absolute",
      top: "0"
    });
    var HTMLProviderPin = class extends ProviderPin {
      static get baseStyle() {
        return htmlPinBaseStyle;
      }
      constructor(options) {
        super(options);
        this._pinEl = document.createElement("button");
        Object.assign(this._pinEl.style, this.constructor.baseStyle);
        this._pinAlt = document.createElement("span");
        this._pinAlt.classList.add("sr-only");
        this._pinEl.appendChild(this._pinAlt);
        this._wrapper = document.createElement("div");
        this._wrapper.style.pointerEvents = "none";
        this._wrapper.appendChild(this._pinEl);
        this.addListeners();
      }
      addListeners() {
        this._wrapper.addEventListener("click", () => this._clickHandler());
        this._wrapper.addEventListener("focusin", () => this._focusHandler(true));
        this._wrapper.addEventListener("focusout", () => this._focusHandler(false));
        this._wrapper.addEventListener("mouseover", () => this._hoverHandler(true));
        this._wrapper.addEventListener("mouseout", () => this._hoverHandler(false));
      }
      getPinElement() {
        return this._pinEl;
      }
      getWrapperElement() {
        return this._wrapper;
      }
      setProperties(pinProperties) {
        this.setElementProperties(pinProperties);
        const className = pinProperties.getClass();
        const element = pinProperties.getElement() || this._pinEl;
        const zIndex = pinProperties.getZIndex();
        element.style.pointerEvents = "auto";
        if (this._wrapper) {
          this._wrapper.style.zIndex = zIndex;
          this._wrapper.setAttribute("class", className);
          if (element != this._wrapper.children[0]) {
            this._wrapper.children[0].style.pointerEvents = "";
            this._wrapper.removeChild(this._wrapper.children[0]);
            this._wrapper.appendChild(element);
          }
        }
      }
      setElementProperties(pinProperties) {
        const anchorX = pinProperties.getAnchorX();
        const anchorY = pinProperties.getAnchorY();
        const height = pinProperties.getHeight();
        const icon = this._icons[pinProperties.getIcon()];
        const srText = pinProperties.getSRText();
        const width = pinProperties.getWidth();
        Object.assign(this._pinEl.style, {
          backgroundImage: icon ? `url("${icon}")` : "",
          height: height + "px",
          transform: `translate(${-100 * anchorX}%, ${-100 * anchorY}%)`,
          width: width + "px"
        });
        this._pinAlt.innerText = srText;
      }
    };
    exports.HTMLProviderPin = HTMLProviderPin;
  }
});

// node_modules/@yext/components-tsx-maps/dist/MapProvider.js
var require_MapProvider = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/MapProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapProvider = exports.MapProviderOptions = void 0;
    var Assertions_js_1 = require_Assertions();
    var ProviderMap_js_1 = require_ProviderMap();
    var ProviderPin_js_1 = require_ProviderPin();
    var MapProviderOptions = class {
      constructor() {
        this.loadFunction = (resolve, reject, apiKey, options) => resolve();
        this.mapClass = ProviderMap_js_1.ProviderMap;
        this.pinClass = ProviderPin_js_1.ProviderPin;
        this.providerName = "";
      }
      withLoadFunction(loadFunction) {
        (0, Assertions_js_1.assertType)(loadFunction, Assertions_js_1.Type.FUNCTION);
        this.loadFunction = loadFunction;
        return this;
      }
      withMapClass(mapClass) {
        this.mapClass = mapClass;
        return this;
      }
      withPinClass(pinClass) {
        this.pinClass = pinClass;
        return this;
      }
      withProviderName(providerName) {
        this.providerName = providerName;
        return this;
      }
      build() {
        return new MapProvider(this);
      }
    };
    exports.MapProviderOptions = MapProviderOptions;
    var MapProvider = class {
      constructor(options) {
        (0, Assertions_js_1.assertInstance)(options, MapProviderOptions);
        this._loadFunction = options.loadFunction;
        this._mapClass = options.mapClass;
        this._pinClass = options.pinClass;
        this._providerName = options.providerName;
        this._loadPromise = new Promise((resolve, reject) => {
          this._resolveLoad = resolve;
          this._rejectLoad = reject;
        });
        this._apiKey = "";
        this._loadInvoked = false;
        this._loaded = false;
        this._options = {};
      }
      get loaded() {
        return this._loaded;
      }
      getMapClass() {
        return this._mapClass;
      }
      getPinClass() {
        return this._pinClass;
      }
      getProviderName() {
        return this._providerName;
      }
      async load(apiKey = this._apiKey, options = this._options) {
        if (!this._loadInvoked) {
          this._loadInvoked = true;
          this._loadFunction(this._resolveLoad, this._rejectLoad, apiKey, options);
        }
        await this.ready();
        this._loaded = true;
      }
      async ready() {
        await this._loadPromise;
      }
      setLoadOptions(apiKey, options = null) {
        if (!this._loadInvoked) {
          this._apiKey = apiKey;
          this._options = options || this._options;
        }
      }
    };
    exports.MapProvider = MapProvider;
  }
});

// node_modules/@yext/components-tsx-maps/dist/PinProperties.js
var require_PinProperties = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/PinProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PinProperties = void 0;
    var PinProperties = class {
      constructor() {
        this._anchorX = 0.5;
        this._anchorY = 1;
        this._height = 39;
        this._icon = "default";
        this._srText = "map pin";
        this._width = 33;
        this._zIndex = 0;
        this._class = "";
        this._element = null;
      }
      getAnchorX() {
        return this._anchorX;
      }
      getAnchorY() {
        return this._anchorY;
      }
      getClass() {
        return this._class;
      }
      getElement() {
        return this._element;
      }
      getHeight() {
        return this._height;
      }
      getIcon() {
        return this._icon;
      }
      getSRText() {
        return this._srText;
      }
      getWidth() {
        return this._width;
      }
      getZIndex() {
        return this._zIndex;
      }
      setAnchorX(anchorX) {
        this._anchorX = anchorX;
        return this;
      }
      setAnchorY(anchorY) {
        this._anchorY = anchorY;
        return this;
      }
      setClass(className) {
        this._class = className;
        return this;
      }
      setElement(element) {
        this._element = element;
        return this;
      }
      setHeight(height) {
        this._height = height;
        return this;
      }
      setIcon(icon) {
        this._icon = icon;
        return this;
      }
      setSRText(srText) {
        this._srText = srText;
        return this;
      }
      setWidth(width) {
        this._width = width;
        return this;
      }
      setZIndex(zIndex) {
        this._zIndex = zIndex;
        return this;
      }
    };
    exports.PinProperties = PinProperties;
  }
});

// node_modules/@yext/components-tsx-maps/dist/MapPin.js
var require_MapPin = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/MapPin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PinProperties = exports.MapPin = exports.MapPinOptions = void 0;
    var components_tsx_geo_1 = require_dist();
    var Assertions_js_1 = require_Assertions();
    var Map_js_1 = require_Map();
    var MapProvider_js_1 = require_MapProvider();
    var PinProperties_js_1 = require_PinProperties();
    Object.defineProperty(exports, "PinProperties", { enumerable: true, get: function() {
      return PinProperties_js_1.PinProperties;
    } });
    var ProviderPin_js_1 = require_ProviderPin();
    var MapPinOptions = class {
      constructor() {
        this.coordinate = new components_tsx_geo_1.Coordinate(0, 0);
        this.hideOffscreen = false;
        this.icons = {};
        this.propertiesForStatus = (status) => new PinProperties_js_1.PinProperties();
        this.provider = null;
        this.type = "";
      }
      withCoordinate(coordinate) {
        this.coordinate = new components_tsx_geo_1.Coordinate(coordinate);
        return this;
      }
      withHideOffscreen(hideOffscreen) {
        this.hideOffscreen = hideOffscreen;
        return this;
      }
      withIcon(key, icon) {
        this.icons[key] = icon;
        return this;
      }
      withPropertiesForStatus(propertiesForStatus) {
        (0, Assertions_js_1.assertType)(propertiesForStatus, Assertions_js_1.Type.FUNCTION);
        this.propertiesForStatus = propertiesForStatus;
        return this;
      }
      withProvider(provider) {
        (0, Assertions_js_1.assertInstance)(provider, MapProvider_js_1.MapProvider);
        this.provider = provider;
        return this;
      }
      withType(type) {
        this.type = type;
        return this;
      }
      build() {
        return new MapPin(this);
      }
    };
    exports.MapPinOptions = MapPinOptions;
    var MapPin = class {
      constructor(options) {
        (0, Assertions_js_1.assertInstance)(options, MapPinOptions);
        (0, Assertions_js_1.assertInstance)(options.provider, MapProvider_js_1.MapProvider);
        if (!options.provider.loaded) {
          throw new Error(`MapProvider '${options.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling MapPin constructor.`);
        }
        this._coordinate = options.coordinate;
        this._hideOffscreen = options.hideOffscreen;
        this._icons = Object.assign({}, options.icons);
        this._propertiesForStatus = options.propertiesForStatus;
        this._type = options.type;
        this._clickHandler = () => {
        };
        this._focusHandler = (focused) => this._hoverHandler(focused);
        this._hoverHandler = (hovered) => {
        };
        this._hidden = false;
        this._cancelHiddenUpdater = () => {
        };
        this._map = null;
        this._pin = new ProviderPin_js_1.ProviderPinOptions(options.provider).withIcons(Object.assign({}, this._icons)).withClickHandler(() => this._clickHandler()).withFocusHandler((focused) => this._focusHandler(focused)).withHoverHandler((hovered) => this._hoverHandler(hovered)).build();
        this._pin.setCoordinate(options.coordinate);
        this._status = {};
        this.setStatus(this._status);
      }
      getCoordinate() {
        return this._coordinate;
      }
      getIcon(key) {
        return this._icons[key];
      }
      getMap() {
        return this._map;
      }
      getProviderPin() {
        return this._pin;
      }
      getType() {
        return this._type;
      }
      remove() {
        this.setMap(null);
      }
      setClickHandler(clickHandler) {
        (0, Assertions_js_1.assertType)(clickHandler, Assertions_js_1.Type.FUNCTION);
        this._clickHandler = clickHandler;
      }
      setCoordinate(coordinate) {
        this._coordinate = new components_tsx_geo_1.Coordinate(coordinate);
        this._pin.setCoordinate(this._coordinate);
        if (this._hideOffscreen) {
          this._hideIfOffscreen();
        }
      }
      setFocusHandler(focusHandler) {
        (0, Assertions_js_1.assertType)(focusHandler, Assertions_js_1.Type.FUNCTION);
        this._focusHandler = focusHandler;
      }
      setHoverHandler(hoverHandler) {
        (0, Assertions_js_1.assertType)(hoverHandler, Assertions_js_1.Type.FUNCTION);
        this._hoverHandler = hoverHandler;
      }
      setMap(map) {
        if (map == this._map) {
          return;
        }
        if (map !== null) {
          (0, Assertions_js_1.assertInstance)(map, Map_js_1.Map);
        }
        this._pin.setMap(map, this._hidden ? null : this._map);
        this._map = map;
        this._hidden = false;
        this._cancelHiddenUpdater();
        if (map && this._hideOffscreen) {
          let hiddenUpdaterCancelled = false;
          const hiddenUpdaterCancelledPromise = new Promise((resolve) => {
            this._cancelHiddenUpdater = () => {
              hiddenUpdaterCancelled = true;
              resolve();
            };
          });
          (async () => {
            while (!hiddenUpdaterCancelled) {
              this._hideIfOffscreen();
              await Promise.race([hiddenUpdaterCancelledPromise, map.moving()]);
              await Promise.race([hiddenUpdaterCancelledPromise, map.idle()]);
            }
          })();
        }
      }
      setStatus(status) {
        Object.assign(this._status, status);
        this._pin.setProperties(this._propertiesForStatus(this._status));
      }
      _hideIfOffscreen() {
        if (this._map) {
          const isVisible = this._map.getBounds().contains(this._coordinate);
          if (this._hidden && isVisible) {
            this._pin.setMap(this._map, null);
          } else if (!this._hidden && !isVisible) {
            this._pin.setMap(null, this._map);
          }
          this._hidden = !isVisible;
        }
      }
    };
    exports.MapPin = MapPin;
  }
});

// node_modules/@yext/components-tsx-maps/dist/Map.js
var require_Map = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/Map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Map = exports.MapOptions = void 0;
    var components_tsx_geo_1 = require_dist();
    var components_tsx_geo_2 = require_dist();
    var components_tsx_geo_3 = require_dist();
    var Assertions_js_1 = require_Assertions();
    var MapPin_js_1 = require_MapPin();
    var MapProvider_js_1 = require_MapProvider();
    var ProviderMap_js_1 = require_ProviderMap();
    var MAX_PADDING = 0.98;
    function normalizePadding(value, basis) {
      return Math.max(typeof value == Assertions_js_1.Type.FUNCTION ? value() : value || 0, 0) / basis;
    }
    var MapOptions = class {
      constructor() {
        this.controlEnabled = true;
        this.defaultCenter = new components_tsx_geo_2.Coordinate(39.83, -98.58);
        this.defaultZoom = 4;
        this.legendPins = [];
        this.padding = { bottom: () => 50, left: () => 50, right: () => 50, top: () => 50 };
        this.panHandler = (previousBounds, currentBounds) => {
        };
        this.panStartHandler = (currentBounds) => {
        };
        this.provider = null;
        this.providerOptions = {};
        this.singlePinZoom = 14;
        this.wrapper = null;
      }
      withControlEnabled(controlEnabled) {
        this.controlEnabled = controlEnabled;
        return this;
      }
      withDefaultCenter(defaultCenter) {
        this.defaultCenter = new components_tsx_geo_2.Coordinate(defaultCenter);
        return this;
      }
      withDefaultZoom(defaultZoom) {
        this.defaultZoom = defaultZoom;
        return this;
      }
      withLegendPins(legendPins) {
        this.legendPins = Array.from(legendPins);
        return this;
      }
      withPadding(padding) {
        this.padding = padding;
        return this;
      }
      withPanHandler(panHandler) {
        (0, Assertions_js_1.assertType)(panHandler, Assertions_js_1.Type.FUNCTION);
        this.panHandler = panHandler;
        return this;
      }
      withPanStartHandler(panStartHandler) {
        (0, Assertions_js_1.assertType)(panStartHandler, Assertions_js_1.Type.FUNCTION);
        this.panStartHandler = panStartHandler;
        return this;
      }
      withProvider(provider) {
        (0, Assertions_js_1.assertInstance)(provider, MapProvider_js_1.MapProvider);
        this.provider = provider;
        return this;
      }
      withProviderOptions(providerOptions) {
        this.providerOptions = providerOptions;
        return this;
      }
      withSinglePinZoom(singlePinZoom) {
        this.singlePinZoom = singlePinZoom;
        return this;
      }
      withWrapper(wrapper) {
        (0, Assertions_js_1.assertInstance)(wrapper, HTMLElement);
        this.wrapper = wrapper;
        return this;
      }
      build() {
        return new Map(this);
      }
    };
    exports.MapOptions = MapOptions;
    var Map = class {
      constructor(options) {
        (0, Assertions_js_1.assertInstance)(options, MapOptions);
        (0, Assertions_js_1.assertInstance)(options.provider, MapProvider_js_1.MapProvider);
        (0, Assertions_js_1.assertInstance)(options.wrapper, HTMLElement);
        if (!options.provider.loaded) {
          throw new Error(`MapProvider '${options.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling Map constructor.`);
        }
        this._defaultCenter = options.defaultCenter;
        this._defaultZoom = options.defaultZoom;
        this._legendPins = options.legendPins;
        this._provider = options.provider;
        this._singlePinZoom = options.singlePinZoom;
        this._wrapper = options.wrapper;
        this._padding = {};
        this.setPadding(options.padding);
        this._cachedBounds = null;
        this._resolveIdle = () => {
        };
        this._resolveMoving = () => {
        };
        this._idlePromise = Promise.resolve();
        this._setIdle();
        this.setPanHandler(options.panHandler);
        this.setPanStartHandler(options.panStartHandler);
        while (this._wrapper.firstChild) {
          this._wrapper.removeChild(this._wrapper.lastChild);
        }
        this._panHandlerRunning = false;
        this._panStartHandlerRunning = false;
        this._map = new ProviderMap_js_1.ProviderMapOptions(options.provider, this._wrapper).withControlEnabled(options.controlEnabled).withPanHandler(() => this.panHandler()).withPanStartHandler(() => this.panStartHandler()).withProviderOptions(options.providerOptions).build();
        this.setZoomCenter(this._defaultZoom, this._defaultCenter);
        this._currentBounds = this.getBounds();
      }
      fitCoordinates(coordinates, animated = false, maxZoom = this._singlePinZoom) {
        if (coordinates.length) {
          this.setBounds(components_tsx_geo_3.GeoBounds.fit(coordinates), animated, this._padding, maxZoom);
        } else {
          this.setZoomCenter(this._defaultZoom, this._defaultCenter, animated);
        }
      }
      getBounds() {
        if (!this._cachedBounds) {
          const pixelHeight = this._wrapper.offsetHeight;
          const pixelWidth = this._wrapper.offsetWidth;
          const zoom = this.getZoom();
          const center = this.getCenter();
          const degreesPerPixel = 360 / Math.pow(2, zoom + 8);
          const width = pixelWidth * degreesPerPixel;
          const height = pixelHeight * degreesPerPixel;
          this._cachedBounds = new components_tsx_geo_3.GeoBounds(center, center);
          this._cachedBounds.ne.add(height / 2, width / 2, components_tsx_geo_1.Unit.DEGREE, components_tsx_geo_1.Projection.MERCATOR);
          this._cachedBounds.sw.add(-height / 2, -width / 2, components_tsx_geo_1.Unit.DEGREE, components_tsx_geo_1.Projection.MERCATOR);
          this.moving().then(() => this._cachedBounds = null);
        }
        return new components_tsx_geo_3.GeoBounds(this._cachedBounds.sw, this._cachedBounds.ne);
      }
      getCenter() {
        return this._map.getCenter();
      }
      getProviderMap() {
        return this._map;
      }
      getZoom() {
        return this._map.getZoom();
      }
      async idle() {
        await this._idlePromise;
      }
      async moving() {
        await this._movingPromise;
      }
      newPinOptions() {
        return new MapPin_js_1.MapPinOptions().withProvider(this._provider);
      }
      panHandler() {
        if (this._panHandlerRunning) {
          return;
        }
        this._panHandlerRunning = true;
        requestAnimationFrame(() => {
          const previousBounds = this._currentBounds;
          this._currentBounds = this.getBounds();
          this._panHandler(previousBounds, new components_tsx_geo_3.GeoBounds(new components_tsx_geo_2.Coordinate(this._currentBounds.sw), new components_tsx_geo_2.Coordinate(this._currentBounds.ne)));
          this._panHandlerRunning = false;
        });
        this._setIdle();
      }
      panStartHandler() {
        if (this._panStartHandlerRunning) {
          return;
        }
        this._panStartHandlerRunning = true;
        requestAnimationFrame(() => {
          this._panStartHandler(new components_tsx_geo_3.GeoBounds(new components_tsx_geo_2.Coordinate(this._currentBounds.sw), new components_tsx_geo_2.Coordinate(this._currentBounds.ne)));
          this._panStartHandlerRunning = false;
        });
        this._setMoving();
      }
      setBounds({ ne, sw }, animated = false, padding = {}, maxZoom = Infinity) {
        const pixelHeight = this._wrapper.offsetHeight;
        const pixelWidth = this._wrapper.offsetWidth;
        if (!pixelHeight || !pixelWidth) {
          return;
        }
        let paddingBottom = normalizePadding(padding.bottom, pixelHeight);
        let paddingLeft = normalizePadding(padding.left, pixelWidth);
        let paddingRight = normalizePadding(padding.right, pixelWidth);
        let paddingTop = normalizePadding(padding.top, pixelHeight);
        let horizontalPadding = paddingLeft + paddingRight;
        let verticalPadding = paddingBottom + paddingTop;
        if (horizontalPadding > MAX_PADDING) {
          paddingLeft *= MAX_PADDING / horizontalPadding;
          paddingRight *= MAX_PADDING / horizontalPadding;
          horizontalPadding = MAX_PADDING;
        }
        if (verticalPadding > MAX_PADDING) {
          paddingBottom *= MAX_PADDING / verticalPadding;
          paddingTop *= MAX_PADDING / verticalPadding;
          verticalPadding = MAX_PADDING;
        }
        const paddingInnerHeight = pixelHeight * (1 - verticalPadding);
        const paddingInnerWidth = pixelWidth * (1 - horizontalPadding);
        const bounds = new components_tsx_geo_3.GeoBounds(sw, ne);
        const nw = new components_tsx_geo_2.Coordinate(bounds.ne.latitude, bounds.sw.longitude);
        const height = bounds.sw.distanceTo(nw, components_tsx_geo_1.Unit.DEGREE, components_tsx_geo_1.Projection.MERCATOR);
        const width = (bounds.ne.longitude - nw.longitude + 360) % 360;
        let newHeight = Math.max(height, width * paddingInnerHeight / paddingInnerWidth) / (1 - verticalPadding);
        let newWidth = Math.max(width, height * paddingInnerWidth / paddingInnerHeight) / (1 - horizontalPadding);
        let zoom = Math.log2(pixelWidth * 360 / newWidth) - 8;
        if (zoom > maxZoom) {
          zoom = maxZoom;
          newWidth = pixelWidth * 360 / 2 ** (zoom + 8);
          newHeight = newWidth * pixelHeight / pixelWidth;
        }
        const center = bounds.getCenter(components_tsx_geo_1.Projection.MERCATOR);
        const deltaLat = (paddingTop - paddingBottom) / 2 * newHeight;
        const deltaLon = (paddingRight - paddingLeft) / 2 * newWidth;
        center.add(deltaLat, deltaLon, components_tsx_geo_1.Unit.DEGREE, components_tsx_geo_1.Projection.MERCATOR);
        this.setZoomCenter(zoom, center, animated);
      }
      setCenter(coordinate, animated = false) {
        this._map.setCenter(new components_tsx_geo_2.Coordinate(coordinate), animated);
      }
      setPadding({ bottom = this._padding.bottom, left = this._padding.left, right = this._padding.right, top = this._padding.top }) {
        this._padding = { bottom, left, right, top };
        return this;
      }
      setPanHandler(panHandler) {
        (0, Assertions_js_1.assertType)(panHandler, Assertions_js_1.Type.FUNCTION);
        this._panHandler = panHandler;
      }
      setPanStartHandler(panStartHandler) {
        (0, Assertions_js_1.assertType)(panStartHandler, Assertions_js_1.Type.FUNCTION);
        this._panStartHandler = panStartHandler;
      }
      setZoom(zoom, animated = false) {
        this._map.setZoom(zoom, animated);
      }
      setZoomCenter(zoom, center, animated = false) {
        this._map.setZoomCenter(zoom, center, animated);
      }
      _setIdle() {
        this._resolveMoving();
        this._movingPromise = new Promise((resolve) => this._resolveMoving = resolve);
        this._resolveIdle();
      }
      _setMoving() {
        this._resolveIdle();
        this._idlePromise = new Promise((resolve) => this._resolveIdle = resolve);
        this._resolveMoving();
      }
    };
    exports.Map = Map;
  }
});

// node_modules/@yext/components-tsx-maps/dist/performance/LoadContent.js
var require_LoadContent = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/performance/LoadContent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoadScript = void 0;
    function LoadScript(src, cb = () => {
    }) {
      const script = document.createElement("script");
      script.async = true;
      script.onload = cb;
      script.src = src;
      document.head.appendChild(script);
    }
    exports.LoadScript = LoadScript;
  }
});

// node_modules/@yext/components-tsx-maps/dist/Providers/Google.js
var require_Google = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/Providers/Google.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Library = exports.GoogleMaps = void 0;
    var components_tsx_geo_1 = require_dist();
    var LoadContent_js_1 = require_LoadContent();
    var MapProvider_js_1 = require_MapProvider();
    var ProviderMap_js_1 = require_ProviderMap();
    var ProviderPin_js_1 = require_ProviderPin();
    var Library = {
      GEOCODER: "geocoder",
      PLACES: "places"
    };
    exports.Library = Library;
    var GoogleMap = class extends ProviderMap_js_1.ProviderMap {
      constructor(options) {
        super(options);
        this.map = new google.maps.Map(options.wrapper, Object.assign({ disableDefaultUI: !options.controlEnabled, fullscreenControl: false, gestureHandling: options.controlEnabled ? "auto" : "none", mapTypeControl: false, rotateControl: false, scaleControl: false, streetViewControl: false, zoomControl: options.controlEnabled, zoomControlOptions: {
          position: google.maps.ControlPosition.RIGHT_TOP
        } }, options.providerOptions));
        this._moving = false;
        google.maps.event.addListener(this.map, "bounds_changed", () => {
          if (!this._moving) {
            this._moving = true;
            this._panStartHandler();
          }
        });
        google.maps.event.addListener(this.map, "idle", () => {
          this._moving = false;
          this._panHandler();
        });
      }
      getCenter() {
        return new components_tsx_geo_1.Coordinate(this.map.getCenter());
      }
      getZoom() {
        return this.map.getZoom();
      }
      setCenter(coordinate, animated) {
        const latLng = new google.maps.LatLng(coordinate.latitude, coordinate.longitude);
        if (animated) {
          this.map.panTo(latLng);
        } else {
          this.map.setCenter(latLng);
        }
      }
      setZoom(zoom, animated) {
        this.map.setZoom(Math.floor(zoom));
      }
      setZoomCenter(zoom, center, animated) {
        this.setCenter(center, animated);
        this.setZoom(zoom, animated);
      }
    };
    var GooglePin = class extends ProviderPin_js_1.HTMLProviderPin {
      constructor(options) {
        super(options);
        this._wrapper.style.position = "absolute";
        google.maps.OverlayView.preventMapHitsAndGesturesFrom(this._wrapper);
        const that = this;
        class CustomMarker extends google.maps.OverlayView {
          draw() {
            var _a;
            const position = (_a = this.getProjection()) === null || _a === void 0 ? void 0 : _a.fromLatLngToDivPixel(that._latLng);
            if (position) {
              that._wrapper.style.left = position.x + "px";
              that._wrapper.style.top = position.y + "px";
            }
          }
          onAdd() {
            this.getPanes().floatPane.appendChild(that._wrapper);
          }
          onRemove() {
            var _a;
            (_a = that._wrapper.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(that._wrapper);
          }
        }
        this.pin = new CustomMarker();
      }
      setCoordinate(coordinate) {
        this._latLng = new google.maps.LatLng(coordinate.latitude, coordinate.longitude);
        this.pin.draw();
      }
      setMap(newMap, currentMap) {
        this.pin.setMap(newMap ? newMap.getProviderMap().map : null);
      }
    };
    var globalCallback = "GoogleMapsCallback_b7d77ff2";
    var baseUrl = "https://maps.googleapis.com/maps/api/js";
    function load(resolve, reject, apiKey, { autocomplete = false, channel = window.location.hostname, client, language, libraries = [], params = {} } = {}) {
      window[globalCallback] = resolve;
      if (autocomplete) {
        libraries.push(Library.GEOCODER, Library.PLACES);
      }
      const apiParams = Object.assign({
        callback: globalCallback,
        channel,
        language,
        libraries: libraries.join(",")
      }, params);
      if (apiKey) {
        apiParams.key = apiKey;
      }
      if (client) {
        apiParams.client = client;
      }
      (0, LoadContent_js_1.LoadScript)(baseUrl + "?" + Object.entries(apiParams).map(([key, value]) => key + "=" + value).join("&"));
    }
    var GoogleMaps = new MapProvider_js_1.MapProviderOptions().withLoadFunction(load).withMapClass(GoogleMap).withPinClass(GooglePin).withProviderName("Google").build();
    exports.GoogleMaps = GoogleMaps;
  }
});

// node_modules/@yext/components-tsx-maps/dist/Providers/Mapbox.js
var require_Mapbox = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/Providers/Mapbox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapboxMaps = void 0;
    var components_tsx_geo_1 = require_dist();
    var MapProvider_js_1 = require_MapProvider();
    var ProviderMap_js_1 = require_ProviderMap();
    var ProviderPin_js_1 = require_ProviderPin();
    var MapboxMap = class extends ProviderMap_js_1.ProviderMap {
      constructor(options) {
        super(options);
        this.map = new mapboxgl.Map(Object.assign({ container: options.wrapper, interactive: options.controlEnabled, style: "mapbox://styles/mapbox/streets-v9" }, options.providerOptions));
        if (options.controlEnabled) {
          const zoomControl = new mapboxgl.NavigationControl({ showCompass: false });
          this.map.addControl(zoomControl);
        }
        this.map.on("movestart", () => this._panStartHandler());
        this.map.on("moveend", () => this._panHandler());
      }
      getCenter() {
        return new components_tsx_geo_1.Coordinate(this.map.getCenter());
      }
      getZoom() {
        return this.map.getZoom() + 1;
      }
      setCenter(coordinate, animated) {
        const center = new mapboxgl.LngLat(coordinate.longitude, coordinate.latitude);
        this.map[animated ? "panTo" : "setCenter"](center);
      }
      setZoom(zoom, animated) {
        this.map[animated ? "zoomTo" : "setZoom"](zoom - 1);
      }
      setZoomCenter(zoom, coordinate, animated) {
        const center = new mapboxgl.LngLat(coordinate.longitude, coordinate.latitude);
        this.map[animated ? "easeTo" : "jumpTo"]({ center, zoom: zoom - 1 });
      }
    };
    var MapboxPin = class extends ProviderPin_js_1.HTMLProviderPin {
      constructor(options) {
        super(options);
        this._wrapper.style.position = "relative";
        this.pin = new mapboxgl.Marker({
          anchor: "top-left",
          element: this._wrapper
        });
      }
      setCoordinate(coordinate) {
        this.pin.setLngLat(new mapboxgl.LngLat(coordinate.longitude, coordinate.latitude));
      }
      setMap(newMap, currentMap) {
        if (newMap) {
          this.pin.addTo(newMap.getProviderMap().map);
        } else {
          this.pin.remove();
        }
      }
    };
    function load(resolve, reject, apiKey, { version = "v1.13.0" } = {}) {
      const baseUrl = `https://api.mapbox.com/mapbox-gl-js/${version}/mapbox-gl`;
      const mapStyle = document.createElement("link");
      mapStyle.rel = "stylesheet";
      mapStyle.href = baseUrl + ".css";
      const mapScript = document.createElement("script");
      mapScript.src = baseUrl + ".js";
      mapScript.onload = () => {
        mapboxgl.accessToken = apiKey;
        resolve();
      };
      document.head.appendChild(mapStyle);
      document.head.appendChild(mapScript);
    }
    var MapboxMaps = new MapProvider_js_1.MapProviderOptions().withLoadFunction(load).withMapClass(MapboxMap).withPinClass(MapboxPin).withProviderName("Mapbox").build();
    exports.MapboxMaps = MapboxMaps;
  }
});

// node_modules/@yext/components-tsx-maps/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@yext/components-tsx-maps/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Map(), exports);
    __exportStar(require_MapPin(), exports);
    __exportStar(require_MapProvider(), exports);
    __exportStar(require_PinProperties(), exports);
    __exportStar(require_ProviderMap(), exports);
    __exportStar(require_ProviderPin(), exports);
    __exportStar(require_Google(), exports);
    __exportStar(require_Mapbox(), exports);
  }
});

export {
  require_dist,
  require_dist2
};
//# sourceMappingURL=chunk-5GPQMZRT.js.map
