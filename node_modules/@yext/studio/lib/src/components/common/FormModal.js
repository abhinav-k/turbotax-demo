import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useMemo, useState } from "react";
import Modal from "./Modal";
export default function FormModal({ isOpen, title, instructions, formData, initialFormValue, errorMessage, confirmButtonText = "Save", closeOnConfirm = true, requireChangesToSubmit, handleClose: customHandleClose, handleConfirm: customHandleConfirm, transformOnChangeValue, }) {
    const baseForm = useMemo(() => {
        return initialFormValue ?? getEmptyForm(formData);
    }, [initialFormValue, formData]);
    const [isValidForm, setIsValidForm] = useState(true);
    const [formValue, setFormValue] = useState(baseForm);
    const handleClose = useCallback(async () => {
        setFormValue(baseForm);
        setIsValidForm(true);
        await customHandleClose();
    }, [customHandleClose, baseForm]);
    const handleConfirm = useCallback(async () => {
        if (await customHandleConfirm(formValue)) {
            closeOnConfirm && (await handleClose());
            initialFormValue && requireChangesToSubmit && setFormValue(formValue);
        }
        else {
            setIsValidForm(false);
        }
    }, [
        formValue,
        customHandleConfirm,
        handleClose,
        initialFormValue,
        closeOnConfirm,
        requireChangesToSubmit,
    ]);
    const updateFormField = useCallback((field, value) => {
        setFormValue((prev) => ({ ...prev, [field]: value }));
        setIsValidForm(true);
    }, []);
    const hasChanges = useMemo(() => Object.entries(formValue).some(([field, val]) => val !== baseForm[field]), [formValue, baseForm]);
    const isConfirmButtonDisabled = !isValidForm ||
        !getIsFormFilled(formValue, formData) ||
        (requireChangesToSubmit && !hasChanges);
    const modalBodyContent = useMemo(() => {
        return (_jsxs(_Fragment, { children: [instructions && _jsx("div", { className: "italic mb-4", children: instructions }), Object.entries(formValue).map(([field, val]) => (_jsx(FormField, { field: field, description: formData[field].description, value: val, updateFormField: updateFormField, transformOnChangeValue: transformOnChangeValue }, field)))] }));
    }, [
        formData,
        formValue,
        updateFormField,
        transformOnChangeValue,
        instructions,
    ]);
    return (_jsx(Modal, { isOpen: isOpen, title: title, errorMessage: !isValidForm ? errorMessage : undefined, handleClose: handleClose, handleConfirm: handleConfirm, body: modalBodyContent, confirmButtonText: confirmButtonText, isConfirmButtonDisabled: isConfirmButtonDisabled }));
}
function getEmptyForm(formData) {
    const entries = Object.keys(formData).map((field) => [field, ""]);
    return Object.fromEntries(entries);
}
function getIsFormFilled(form, formData) {
    return Object.entries(form).every(([field, val]) => formData[field].optional || val);
}
function FormField({ field, description, value, updateFormField, transformOnChangeValue, }) {
    const handleChange = useCallback((e) => {
        const value = e.target.value.trim();
        const transformedValue = transformOnChangeValue?.(value, field) ?? value;
        updateFormField(field, transformedValue);
    }, [field, updateFormField, transformOnChangeValue]);
    const inputId = `${field}-input`;
    return (_jsxs(_Fragment, { children: [_jsx("label", { htmlFor: inputId, children: description }), _jsx("input", { id: inputId, type: "text", className: "border border-gray-500 rounded-lg mt-2 mb-4 px-2 py-1 w-full", value: value, onChange: handleChange })] }));
}
//# sourceMappingURL=FormModal.js.map