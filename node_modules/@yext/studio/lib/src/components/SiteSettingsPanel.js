import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { PropValueType, TypeGuards, PropValueKind, } from "@yext/studio-plugin";
import React, { useCallback, useMemo } from "react";
import { startCase } from "lodash";
import useStudioStore from "../store/useStudioStore";
import PropInput from "./PropInput";
/**
 * SiteSettingsPanel renders an editor for SiteSettings.
 * It supports SiteSettings that contain nested objects.
 */
export default function SiteSettingsPanel() {
    const [siteSettingsShape, siteSettingsValues, setValues] = useStudioStore((store) => [
        store.siteSettings.shape ?? {},
        store.siteSettings.values ?? {},
        store.siteSettings.setValues,
    ]);
    const updateValues = useCallback((propName, updatedProp) => {
        setValues({ ...siteSettingsValues, [propName]: updatedProp });
    }, [siteSettingsValues, setValues]);
    return (_jsx("div", { children: renderSiteSettings(siteSettingsShape, siteSettingsValues, updateValues) }));
}
/**
 * Renders the given SiteSettingsShape and SiteSettingsValues.
 *
 * Sorts the SiteSettingsShape so that site settings values that are
 * objects are rendered first.
 */
function renderSiteSettings(siteSettingsShape, siteSettingsValues, updateValues) {
    const sortedShape = Object.entries(siteSettingsShape).sort(([_, firstMetadata]) => {
        return firstMetadata.type === PropValueType.Object ? -1 : 1;
    });
    return sortedShape.map(([propName, propMetadata], index) => {
        const valueType = propMetadata.type;
        const propVal = siteSettingsValues[propName];
        if (valueType !== PropValueType.Object) {
            return (_jsx(SimplePropInput, { propName: propName, valueType: valueType, value: propVal?.value, updateValues: updateValues, unionValues: propMetadata["unionValues"] }, propName));
        }
        const shouldRenderDivider = index < sortedShape.length - 1;
        return (_jsxs(React.Fragment, { children: [_jsx("div", { className: "font-bold pb-2", children: propName }), _jsx(RecursiveGroup, { propName: propName, propVal: propVal, propType: propMetadata, updateValues: updateValues }), shouldRenderDivider && (_jsx("hr", { className: "bg-gray-300 h-0.5 rounded-md my-4" }))] }, propName));
    });
}
/**
 * RecursiveGroup renders a sub-grouping of SiteSettings.
 * It handles nested SiteSettings by recursively calling itself via renderSiteSettings.
 */
function RecursiveGroup(props) {
    const { propType, updateValues, propName, propVal } = props;
    const updateChildValues = useCallback((childPropName, updatedProp) => {
        updateValues(propName, {
            ...propVal,
            value: {
                ...propVal.value,
                [childPropName]: updatedProp,
            },
        });
    }, [updateValues, propName, propVal]);
    return (_jsx(_Fragment, { children: renderSiteSettings(propType.shape, propVal.value, updateChildValues) }));
}
function SimplePropInput(props) {
    const { value, valueType, updateValues, propName, unionValues } = props;
    const handleUpdate = useCallback((rawValue) => {
        const updatedValue = {
            kind: PropValueKind.Literal,
            value: rawValue,
            valueType,
        };
        if (!TypeGuards.isValidPropVal(updatedValue)) {
            console.error("Invalid PropVal when updating SiteSettings:", updatedValue);
            return null;
        }
        updateValues(propName, updatedValue);
    }, [propName, updateValues, valueType]);
    const propType = useMemo(() => ({
        type: valueType,
    }), [valueType]);
    return (_jsxs("label", { id: propName, className: "flex flex-col mb-2", children: [_jsx("span", { children: startCase(propName) }), _jsx(PropInput, { propType: propType, propValue: value, onChange: handleUpdate, unionValues: unionValues, propKind: PropValueKind.Literal })] }));
}
//# sourceMappingURL=SiteSettingsPanel.js.map