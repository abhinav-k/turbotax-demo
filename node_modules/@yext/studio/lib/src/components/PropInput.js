import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { PropValueKind, PropValueType, TypeGuards, } from "@yext/studio-plugin";
import { useCallback, useLayoutEffect } from "react";
import Toggle from "./common/Toggle";
import PropValueHelpers from "../utils/PropValueHelpers";
import TemplateExpressionFormatter from "../utils/TemplateExpressionFormatter";
import FieldPickerInput from "./FieldPicker/FieldPickerInput";
import ColorPicker from "./common/ColorPicker";
const inputBoxCssClasses = "border border-gray-300 focus:border-indigo-500 rounded-lg p-2";
const selectCssClasses = "bg-gray-50 border border-gray-300 text-gray-900 rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2.5";
/**
 * Renders the input element of a PropEditor component, that
 * will update the corresponding prop's value for the active
 * component based on user's input.
 */
export default function PropInput({ propType, propValue, onChange, unionValues, propKind, }) {
    const { type } = propType;
    const handleChangeEvent = useCallback((e) => {
        const getValue = () => {
            if (e.target instanceof HTMLSelectElement) {
                return e.target.value;
            }
            if (type === PropValueType.number) {
                return e.target.valueAsNumber;
            }
            else if (type === PropValueType.boolean) {
                return e.target.checked;
            }
            else if (propKind === PropValueKind.Expression &&
                type === PropValueType.string) {
                return TemplateExpressionFormatter.getRawValue(e.target.value);
            }
            return e.target.value;
        };
        onChange(getValue());
    }, [onChange, propKind, type]);
    const displayValue = useDisplayValue(propValue, type, propKind, onChange);
    const appendField = useCallback((fieldId) => {
        const documentUsage = "${" + fieldId + "}";
        const appendedValue = displayValue
            ? `${displayValue} ${documentUsage}`
            : documentUsage;
        onChange(TemplateExpressionFormatter.getRawValue(appendedValue));
    }, [displayValue, onChange]);
    const fieldPickerFilter = useCallback((value) => TypeGuards.valueMatchesPropType(propType, value), [propType]);
    if (unionValues) {
        return (_jsx("select", { onChange: handleChangeEvent, className: selectCssClasses, value: propValue, children: unionValues.map((val) => {
                return (_jsx("option", { value: val, children: val }, val));
            }) }));
    }
    switch (type) {
        case PropValueType.number:
            return (_jsx("input", { type: "number", onChange: handleChangeEvent, className: inputBoxCssClasses, value: displayValue }));
        case PropValueType.string:
            return (_jsx(FieldPickerInput, { onInputChange: handleChangeEvent, handleFieldSelection: appendField, displayValue: displayValue, fieldFilter: fieldPickerFilter }));
        case PropValueType.boolean:
            return (_jsx(Toggle, { checked: displayValue, onToggle: handleChangeEvent }));
        case PropValueType.HexColor:
            return (_jsx(ColorPicker, { onChange: handleChangeEvent, value: displayValue }));
        case PropValueType.Array:
            return (_jsx(FieldPickerInput, { onInputChange: handleChangeEvent, handleFieldSelection: onChange, displayValue: displayValue, fieldFilter: fieldPickerFilter }));
        default:
            return _jsxs("div", { children: ["Unknown PropValueType ", type, "."] });
    }
}
function useDisplayValue(propValue, propType, propKind, onChange) {
    useLayoutEffect(() => {
        if (propValue === undefined) {
            onChange(PropValueHelpers.getPropInputDefaultValue(propType, propKind));
        }
    }, [propValue, onChange, propType, propKind]);
    const propValueWithDefaulting = propValue ?? PropValueHelpers.getPropInputDefaultValue(propType, propKind);
    if (propKind === PropValueKind.Expression) {
        if (typeof propValueWithDefaulting !== "string") {
            throw new Error(`Only strings are supported as the value for expression props. Received: "${propValueWithDefaulting}".`);
        }
        if (propType === PropValueType.string) {
            return TemplateExpressionFormatter.getTemplateStringDisplayValue(propValueWithDefaulting);
        }
    }
    return propValueWithDefaulting;
}
//# sourceMappingURL=PropInput.js.map