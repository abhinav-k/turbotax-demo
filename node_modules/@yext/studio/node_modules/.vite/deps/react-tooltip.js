import {
  require_react
} from "./chunk-TYR45LGA.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// node_modules/react-tooltip/dist/react-tooltip.esm.min.js
var import_react = __toESM(require_react());
var s;
var u = { exports: {} };
var f = {};
s = f, function() {
  var t2 = import_react.default, n2 = 60103, r2 = 60106;
  s.Fragment = 60107;
  var o2 = 60108, i2 = 60114, l2 = 60109, a2 = 60110, c2 = 60112, u2 = 60113, f2 = 60120, d2 = 60115, p2 = 60116, y2 = 60121, m2 = 60122, h2 = 60117, g2 = 60129, v2 = 60131;
  if ("function" == typeof Symbol && Symbol.for) {
    var w2 = Symbol.for;
    n2 = w2("react.element"), r2 = w2("react.portal"), s.Fragment = w2("react.fragment"), o2 = w2("react.strict_mode"), i2 = w2("react.profiler"), l2 = w2("react.provider"), a2 = w2("react.context"), c2 = w2("react.forward_ref"), u2 = w2("react.suspense"), f2 = w2("react.suspense_list"), d2 = w2("react.memo"), p2 = w2("react.lazy"), y2 = w2("react.block"), m2 = w2("react.server.block"), h2 = w2("react.fundamental"), w2("react.scope"), w2("react.opaque.id"), g2 = w2("react.debug_trace_mode"), w2("react.offscreen"), v2 = w2("react.legacy_hidden");
  }
  var b2 = "function" == typeof Symbol && Symbol.iterator, x2 = t2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function _2(e2) {
    for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
      n3[r3 - 1] = arguments[r3];
    S2("error", e2, n3);
  }
  function S2(e2, t3, n3) {
    var r3 = x2.ReactDebugCurrentFrame, o3 = "";
    if (O2) {
      var i3 = A2(O2.type), l3 = O2._owner;
      o3 += function(e3, t4, n4) {
        var r4 = "";
        if (t4) {
          var o4 = t4.fileName, i4 = o4.replace(T2, "");
          if (/^index\./.test(i4)) {
            var l4 = o4.match(T2);
            if (l4) {
              var a4 = l4[1];
              a4 && (i4 = a4.replace(T2, "") + "/" + i4);
            }
          }
          r4 = " (at " + i4 + ":" + t4.lineNumber + ")";
        } else
          n4 && (r4 = " (created by " + n4 + ")");
        return "\n    in " + (e3 || "Unknown") + r4;
      }(i3, O2._source, l3 && A2(l3.type));
    }
    "" !== (o3 += r3.getStackAddendum()) && (t3 += "%s", n3 = n3.concat([o3]));
    var a3 = n3.map(function(e3) {
      return "" + e3;
    });
    a3.unshift("Warning: " + t3), Function.prototype.apply.call(console[e2], console, a3);
  }
  var T2 = /^(.*)[\\\/]/;
  function A2(e2) {
    if (null == e2)
      return null;
    if ("number" == typeof e2.tag && _2("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), "function" == typeof e2)
      return e2.displayName || e2.name || null;
    if ("string" == typeof e2)
      return e2;
    switch (e2) {
      case s.Fragment:
        return "Fragment";
      case r2:
        return "Portal";
      case i2:
        return "Profiler";
      case o2:
        return "StrictMode";
      case u2:
        return "Suspense";
      case f2:
        return "SuspenseList";
    }
    if ("object" == typeof e2)
      switch (e2.$$typeof) {
        case a2:
          return "Context.Consumer";
        case l2:
          return "Context.Provider";
        case c2:
          return m3 = e2, h3 = e2.render, g3 = "ForwardRef", v3 = h3.displayName || h3.name || "", m3.displayName || ("" !== v3 ? g3 + "(" + v3 + ")" : g3);
        case d2:
          return A2(e2.type);
        case y2:
          return A2(e2.render);
        case p2:
          var t3 = 1 === (n3 = e2)._status ? n3._result : null;
          if (t3)
            return A2(t3);
      }
    var n3, m3, h3, g3, v3;
    return null;
  }
  var R2 = {};
  x2.ReactDebugCurrentFrame;
  var O2 = null;
  function k2(e2) {
    O2 = e2;
  }
  var E2, j2, L2, P2 = x2.ReactCurrentOwner, D2 = Object.prototype.hasOwnProperty, N2 = { key: true, ref: true, __self: true, __source: true };
  function F2(e2, t3, r3, o3, i3) {
    var l3, a3 = {}, c3 = null, s2 = null;
    for (l3 in void 0 !== r3 && (c3 = "" + r3), function(e3) {
      if (D2.call(e3, "key")) {
        var t4 = Object.getOwnPropertyDescriptor(e3, "key").get;
        if (t4 && t4.isReactWarning)
          return false;
      }
      return void 0 !== e3.key;
    }(t3) && (c3 = "" + t3.key), function(e3) {
      if (D2.call(e3, "ref")) {
        var t4 = Object.getOwnPropertyDescriptor(e3, "ref").get;
        if (t4 && t4.isReactWarning)
          return false;
      }
      return void 0 !== e3.ref;
    }(t3) && (s2 = t3.ref, function(e3, t4) {
      if ("string" == typeof e3.ref && P2.current && t4 && P2.current.stateNode !== t4) {
        var n3 = A2(P2.current.type);
        L2[n3] || (_2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', A2(P2.current.type), e3.ref), L2[n3] = true);
      }
    }(t3, i3)), t3)
      D2.call(t3, l3) && !N2.hasOwnProperty(l3) && (a3[l3] = t3[l3]);
    if (e2 && e2.defaultProps) {
      var u3 = e2.defaultProps;
      for (l3 in u3)
        void 0 === a3[l3] && (a3[l3] = u3[l3]);
    }
    if (c3 || s2) {
      var f3 = "function" == typeof e2 ? e2.displayName || e2.name || "Unknown" : e2;
      c3 && function(e3, t4) {
        var n3 = function() {
          E2 || (E2 = true, _2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", t4));
        };
        n3.isReactWarning = true, Object.defineProperty(e3, "key", { get: n3, configurable: true });
      }(a3, f3), s2 && function(e3, t4) {
        var n3 = function() {
          j2 || (j2 = true, _2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", t4));
        };
        n3.isReactWarning = true, Object.defineProperty(e3, "ref", { get: n3, configurable: true });
      }(a3, f3);
    }
    return function(e3, t4, r4, o4, i4, l4, a4) {
      var c4 = { $$typeof: n2, type: e3, key: t4, ref: r4, props: a4, _owner: l4, _store: {} };
      return Object.defineProperty(c4._store, "validated", { configurable: false, enumerable: false, writable: true, value: false }), Object.defineProperty(c4, "_self", { configurable: false, enumerable: false, writable: false, value: o4 }), Object.defineProperty(c4, "_source", { configurable: false, enumerable: false, writable: false, value: i4 }), Object.freeze && (Object.freeze(c4.props), Object.freeze(c4)), c4;
    }(e2, c3, s2, i3, o3, P2.current, a3);
  }
  L2 = {};
  var $2, C2 = x2.ReactCurrentOwner;
  function I2(e2) {
    O2 = e2;
  }
  function W2(e2) {
    return "object" == typeof e2 && null !== e2 && e2.$$typeof === n2;
  }
  function U2() {
    if (C2.current) {
      var e2 = A2(C2.current.type);
      if (e2)
        return "\n\nCheck the render method of `" + e2 + "`.";
    }
    return "";
  }
  x2.ReactDebugCurrentFrame, $2 = false;
  var H2 = {};
  function B2(e2, t3) {
    if (e2._store && !e2._store.validated && null == e2.key) {
      e2._store.validated = true;
      var n3 = function(e3) {
        var t4 = U2();
        if (!t4) {
          var n4 = "string" == typeof e3 ? e3 : e3.displayName || e3.name;
          n4 && (t4 = "\n\nCheck the top-level render call using <" + n4 + ">.");
        }
        return t4;
      }(t3);
      if (!H2[n3]) {
        H2[n3] = true;
        var r3 = "";
        e2 && e2._owner && e2._owner !== C2.current && (r3 = " It was passed a child from " + A2(e2._owner.type) + "."), I2(e2), _2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', n3, r3), I2(null);
      }
    }
  }
  function M2(e2, t3) {
    if ("object" == typeof e2) {
      if (Array.isArray(e2))
        for (var n3 = 0; n3 < e2.length; n3++) {
          var r3 = e2[n3];
          W2(r3) && B2(r3, t3);
        }
      else if (W2(e2))
        e2._store && (e2._store.validated = true);
      else if (e2) {
        var o3 = function(e3) {
          if (null === e3 || "object" != typeof e3)
            return null;
          var t4 = b2 && e3[b2] || e3["@@iterator"];
          return "function" == typeof t4 ? t4 : null;
        }(e2);
        if ("function" == typeof o3 && o3 !== e2.entries)
          for (var i3, l3 = o3.call(e2); !(i3 = l3.next()).done; )
            W2(i3.value) && B2(i3.value, t3);
      }
    }
  }
  function q2(e2) {
    var t3, n3 = e2.type;
    if (null != n3 && "string" != typeof n3) {
      if ("function" == typeof n3)
        t3 = n3.propTypes;
      else {
        if ("object" != typeof n3 || n3.$$typeof !== c2 && n3.$$typeof !== d2)
          return;
        t3 = n3.propTypes;
      }
      if (t3) {
        var r3 = A2(n3);
        !function(e3, t4, n4, r4, o3) {
          var i3 = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var l3 in e3)
            if (i3(e3, l3)) {
              var a3 = void 0;
              try {
                if ("function" != typeof e3[l3]) {
                  var c3 = Error((r4 || "React class") + ": " + n4 + " type `" + l3 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e3[l3] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw c3.name = "Invariant Violation", c3;
                }
                a3 = e3[l3](t4, l3, r4, n4, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (e4) {
                a3 = e4;
              }
              !a3 || a3 instanceof Error || (k2(o3), _2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", r4 || "React class", n4, l3, typeof a3), k2(null)), a3 instanceof Error && !(a3.message in R2) && (R2[a3.message] = true, k2(o3), _2("Failed %s type: %s", n4, a3.message), k2(null));
            }
        }(t3, e2.props, "prop", r3, e2);
      } else
        void 0 === n3.PropTypes || $2 || ($2 = true, _2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", A2(n3) || "Unknown"));
      "function" != typeof n3.getDefaultProps || n3.getDefaultProps.isReactClassApproved || _2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function V2(e2, t3, r3, w3, b3, x3) {
    var S3 = function(e3) {
      return "string" == typeof e3 || "function" == typeof e3 || e3 === s.Fragment || e3 === i2 || e3 === g2 || e3 === o2 || e3 === u2 || e3 === f2 || e3 === v2 || "object" == typeof e3 && null !== e3 && (e3.$$typeof === p2 || e3.$$typeof === d2 || e3.$$typeof === l2 || e3.$$typeof === a2 || e3.$$typeof === c2 || e3.$$typeof === h2 || e3.$$typeof === y2 || e3[0] === m2);
    }(e2);
    if (!S3) {
      var T3 = "";
      (void 0 === e2 || "object" == typeof e2 && null !== e2 && 0 === Object.keys(e2).length) && (T3 += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var R3, O3 = function(e3) {
        return void 0 !== e3 ? "\n\nCheck your code at " + e3.fileName.replace(/^.*[\\\/]/, "") + ":" + e3.lineNumber + "." : "";
      }(b3);
      T3 += O3 || U2(), null === e2 ? R3 = "null" : Array.isArray(e2) ? R3 = "array" : void 0 !== e2 && e2.$$typeof === n2 ? (R3 = "<" + (A2(e2.type) || "Unknown") + " />", T3 = " Did you accidentally export a JSX literal instead of a component?") : R3 = typeof e2, _2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", R3, T3);
    }
    var k3 = F2(e2, t3, r3, b3, x3);
    if (null == k3)
      return k3;
    if (S3) {
      var E3 = t3.children;
      if (void 0 !== E3)
        if (w3)
          if (Array.isArray(E3)) {
            for (var j3 = 0; j3 < E3.length; j3++)
              M2(E3[j3], e2);
            Object.freeze && Object.freeze(E3);
          } else
            _2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          M2(E3, e2);
    }
    return e2 === s.Fragment ? function(e3) {
      for (var t4 = Object.keys(e3.props), n3 = 0; n3 < t4.length; n3++) {
        var r4 = t4[n3];
        if ("children" !== r4 && "key" !== r4) {
          I2(e3), _2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", r4), I2(null);
          break;
        }
      }
      null !== e3.ref && (I2(e3), _2("Invalid attribute `ref` supplied to `React.Fragment`."), I2(null));
    }(k3) : q2(k3), k3;
  }
  var Y2 = function(e2, t3, n3) {
    return V2(e2, t3, n3, false);
  }, z2 = function(e2, t3, n3) {
    return V2(e2, t3, n3, true);
  };
  s.jsx = Y2, s.jsxs = z2;
}(), u.exports = f;
var d;
var p = { exports: {} };
d = p, function() {
  var e2 = {}.hasOwnProperty;
  function t2() {
    for (var n2 = [], r2 = 0; r2 < arguments.length; r2++) {
      var o2 = arguments[r2];
      if (o2) {
        var i2 = typeof o2;
        if ("string" === i2 || "number" === i2)
          n2.push(o2);
        else if (Array.isArray(o2)) {
          if (o2.length) {
            var l2 = t2.apply(null, o2);
            l2 && n2.push(l2);
          }
        } else if ("object" === i2) {
          if (o2.toString !== Object.prototype.toString && !o2.toString.toString().includes("[native code]")) {
            n2.push(o2.toString());
            continue;
          }
          for (var a2 in o2)
            e2.call(o2, a2) && o2[a2] && n2.push(a2);
        }
      }
    }
    return n2.join(" ");
  }
  d.exports ? (t2.default = t2, d.exports = t2) : window.classNames = t2;
}();
var y = p.exports;
var m = (e2, t2, n2) => {
  let r2 = null;
  return function(...o2) {
    r2 && clearTimeout(r2), r2 = setTimeout(() => {
      r2 = null, n2 || e2.apply(this, o2);
    }, t2);
  };
};
var h = ({ content: e2 }) => u.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e2 } });
var g = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} };
var v = (0, import_react.createContext)({ getTooltipData: () => g });
var w = ({ children: e2 }) => {
  const [t2, i2] = (0, import_react.useState)({ DEFAULT_TOOLTIP_ID: /* @__PURE__ */ new Set() }), [l2, a2] = (0, import_react.useState)({ DEFAULT_TOOLTIP_ID: { current: null } }), c2 = (e3, ...t3) => {
    i2((n2) => {
      var r2;
      const o2 = null !== (r2 = n2[e3]) && void 0 !== r2 ? r2 : /* @__PURE__ */ new Set();
      return t3.forEach((e4) => o2.add(e4)), { ...n2, [e3]: new Set(o2) };
    });
  }, s2 = (e3, ...t3) => {
    i2((n2) => {
      const r2 = n2[e3];
      return r2 ? (t3.forEach((e4) => r2.delete(e4)), { ...n2 }) : n2;
    });
  }, f2 = (0, import_react.useCallback)((e3 = "DEFAULT_TOOLTIP_ID") => {
    var n2, r2;
    return { anchorRefs: null !== (n2 = t2[e3]) && void 0 !== n2 ? n2 : /* @__PURE__ */ new Set(), activeAnchor: null !== (r2 = l2[e3]) && void 0 !== r2 ? r2 : { current: null }, attach: (...t3) => c2(e3, ...t3), detach: (...t3) => s2(e3, ...t3), setActiveAnchor: (t3) => ((e4, t4) => {
      a2((n3) => {
        var r3;
        return (null === (r3 = n3[e4]) || void 0 === r3 ? void 0 : r3.current) === t4.current ? n3 : { ...n3, [e4]: t4 };
      });
    })(e3, t3) };
  }, [t2, l2, c2, s2]), d2 = (0, import_react.useMemo)(() => ({ getTooltipData: f2 }), [f2]);
  return u.exports.jsx(v.Provider, { value: d2, children: e2 });
};
function b(e2 = "DEFAULT_TOOLTIP_ID") {
  return (0, import_react.useContext)(v).getTooltipData(e2);
}
var x = ({ tooltipId: e2, children: t2, className: n2, place: r2, content: o2, html: i2, variant: c2, offset: s2, wrapper: f2, events: d2, positionStrategy: p2, delayShow: m2, delayHide: h2 }) => {
  const { attach: g2, detach: v2 } = b(e2), w2 = (0, import_react.useRef)(null);
  return (0, import_react.useEffect)(() => (g2(w2), () => {
    v2(w2);
  }), []), u.exports.jsx("span", { ref: w2, className: y("react-tooltip-wrapper", n2), "data-tooltip-place": r2, "data-tooltip-content": o2, "data-tooltip-html": i2, "data-tooltip-variant": c2, "data-tooltip-offset": s2, "data-tooltip-wrapper": f2, "data-tooltip-events": d2, "data-tooltip-position-strategy": p2, "data-tooltip-delay-show": m2, "data-tooltip-delay-hide": h2, children: t2 });
};
var _ = "undefined" != typeof window ? import_react.useLayoutEffect : import_react.useEffect;
function S(e2) {
  return e2.split("-")[1];
}
function T(e2) {
  return "y" === e2 ? "height" : "width";
}
function A(e2) {
  return e2.split("-")[0];
}
function R(e2) {
  return ["top", "bottom"].includes(A(e2)) ? "x" : "y";
}
function O(e2, t2, n2) {
  let { reference: r2, floating: o2 } = e2;
  const i2 = r2.x + r2.width / 2 - o2.width / 2, l2 = r2.y + r2.height / 2 - o2.height / 2, a2 = R(t2), c2 = T(a2), s2 = r2[c2] / 2 - o2[c2] / 2, u2 = "x" === a2;
  let f2;
  switch (A(t2)) {
    case "top":
      f2 = { x: i2, y: r2.y - o2.height };
      break;
    case "bottom":
      f2 = { x: i2, y: r2.y + r2.height };
      break;
    case "right":
      f2 = { x: r2.x + r2.width, y: l2 };
      break;
    case "left":
      f2 = { x: r2.x - o2.width, y: l2 };
      break;
    default:
      f2 = { x: r2.x, y: r2.y };
  }
  switch (S(t2)) {
    case "start":
      f2[a2] -= s2 * (n2 && u2 ? -1 : 1);
      break;
    case "end":
      f2[a2] += s2 * (n2 && u2 ? -1 : 1);
  }
  return f2;
}
function k(e2) {
  return "number" != typeof e2 ? function(e3) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...e3 };
  }(e2) : { top: e2, right: e2, bottom: e2, left: e2 };
}
function E(e2) {
  return { ...e2, top: e2.y, left: e2.x, right: e2.x + e2.width, bottom: e2.y + e2.height };
}
async function j(e2, t2) {
  var n2;
  void 0 === t2 && (t2 = {});
  const { x: r2, y: o2, platform: i2, rects: l2, elements: a2, strategy: c2 } = e2, { boundary: s2 = "clippingAncestors", rootBoundary: u2 = "viewport", elementContext: f2 = "floating", altBoundary: d2 = false, padding: p2 = 0 } = t2, y2 = k(p2), m2 = a2[d2 ? "floating" === f2 ? "reference" : "floating" : f2], h2 = E(await i2.getClippingRect({ element: null == (n2 = await (null == i2.isElement ? void 0 : i2.isElement(m2))) || n2 ? m2 : m2.contextElement || await (null == i2.getDocumentElement ? void 0 : i2.getDocumentElement(a2.floating)), boundary: s2, rootBoundary: u2, strategy: c2 })), g2 = "floating" === f2 ? { ...l2.floating, x: r2, y: o2 } : l2.reference, v2 = await (null == i2.getOffsetParent ? void 0 : i2.getOffsetParent(a2.floating)), w2 = await (null == i2.isElement ? void 0 : i2.isElement(v2)) && await (null == i2.getScale ? void 0 : i2.getScale(v2)) || { x: 1, y: 1 }, b2 = E(i2.convertOffsetParentRelativeRectToViewportRelativeRect ? await i2.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: g2, offsetParent: v2, strategy: c2 }) : g2);
  return { top: (h2.top - b2.top + y2.top) / w2.y, bottom: (b2.bottom - h2.bottom + y2.bottom) / w2.y, left: (h2.left - b2.left + y2.left) / w2.x, right: (b2.right - h2.right + y2.right) / w2.x };
}
var L = Math.min;
var P = Math.max;
function D(e2, t2, n2) {
  return P(e2, L(t2, n2));
}
var N = { left: "right", right: "left", bottom: "top", top: "bottom" };
function F(e2) {
  return e2.replace(/left|right|bottom|top/g, (e3) => N[e3]);
}
var $ = { start: "end", end: "start" };
function C(e2) {
  return e2.replace(/start|end/g, (e3) => $[e3]);
}
var I = function(e2) {
  return void 0 === e2 && (e2 = {}), { name: "flip", options: e2, async fn(t2) {
    var n2;
    const { placement: r2, middlewareData: o2, rects: i2, initialPlacement: l2, platform: a2, elements: c2 } = t2, { mainAxis: s2 = true, crossAxis: u2 = true, fallbackPlacements: f2, fallbackStrategy: d2 = "bestFit", fallbackAxisSideDirection: p2 = "none", flipAlignment: y2 = true, ...m2 } = e2, h2 = A(r2), g2 = A(l2) === l2, v2 = await (null == a2.isRTL ? void 0 : a2.isRTL(c2.floating)), w2 = f2 || (g2 || !y2 ? [F(l2)] : function(e3) {
      const t3 = F(e3);
      return [C(e3), t3, C(t3)];
    }(l2));
    f2 || "none" === p2 || w2.push(...function(e3, t3, n3, r3) {
      const o3 = S(e3);
      let i3 = function(e4, t4, n4) {
        const r4 = ["left", "right"], o4 = ["right", "left"], i4 = ["top", "bottom"], l3 = ["bottom", "top"];
        switch (e4) {
          case "top":
          case "bottom":
            return n4 ? t4 ? o4 : r4 : t4 ? r4 : o4;
          case "left":
          case "right":
            return t4 ? i4 : l3;
          default:
            return [];
        }
      }(A(e3), "start" === n3, r3);
      return o3 && (i3 = i3.map((e4) => e4 + "-" + o3), t3 && (i3 = i3.concat(i3.map(C)))), i3;
    }(l2, y2, p2, v2));
    const b2 = [l2, ...w2], x2 = await j(t2, m2), _2 = [];
    let O2 = (null == (n2 = o2.flip) ? void 0 : n2.overflows) || [];
    if (s2 && _2.push(x2[h2]), u2) {
      const { main: e3, cross: t3 } = function(e4, t4, n3) {
        void 0 === n3 && (n3 = false);
        const r3 = S(e4), o3 = R(e4), i3 = T(o3);
        let l3 = "x" === o3 ? r3 === (n3 ? "end" : "start") ? "right" : "left" : "start" === r3 ? "bottom" : "top";
        return t4.reference[i3] > t4.floating[i3] && (l3 = F(l3)), { main: l3, cross: F(l3) };
      }(r2, i2, v2);
      _2.push(x2[e3], x2[t3]);
    }
    if (O2 = [...O2, { placement: r2, overflows: _2 }], !_2.every((e3) => e3 <= 0)) {
      var k2, E2;
      const e3 = ((null == (k2 = o2.flip) ? void 0 : k2.index) || 0) + 1, t3 = b2[e3];
      if (t3)
        return { data: { index: e3, overflows: O2 }, reset: { placement: t3 } };
      let n3 = null == (E2 = O2.find((e4) => e4.overflows[0] <= 0)) ? void 0 : E2.placement;
      if (!n3)
        switch (d2) {
          case "bestFit": {
            var L2;
            const e4 = null == (L2 = O2.map((e5) => [e5.placement, e5.overflows.filter((e6) => e6 > 0).reduce((e6, t4) => e6 + t4, 0)]).sort((e5, t4) => e5[1] - t4[1])[0]) ? void 0 : L2[0];
            e4 && (n3 = e4);
            break;
          }
          case "initialPlacement":
            n3 = l2;
        }
      if (r2 !== n3)
        return { reset: { placement: n3 } };
    }
    return {};
  } };
};
var W = function(e2) {
  return void 0 === e2 && (e2 = 0), { name: "offset", options: e2, async fn(t2) {
    const { x: n2, y: r2 } = t2, o2 = await async function(e3, t3) {
      const { placement: n3, platform: r3, elements: o3 } = e3, i2 = await (null == r3.isRTL ? void 0 : r3.isRTL(o3.floating)), l2 = A(n3), a2 = S(n3), c2 = "x" === R(n3), s2 = ["left", "top"].includes(l2) ? -1 : 1, u2 = i2 && c2 ? -1 : 1, f2 = "function" == typeof t3 ? t3(e3) : t3;
      let { mainAxis: d2, crossAxis: p2, alignmentAxis: y2 } = "number" == typeof f2 ? { mainAxis: f2, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...f2 };
      return a2 && "number" == typeof y2 && (p2 = "end" === a2 ? -1 * y2 : y2), c2 ? { x: p2 * u2, y: d2 * s2 } : { x: d2 * s2, y: p2 * u2 };
    }(t2, e2);
    return { x: n2 + o2.x, y: r2 + o2.y, data: o2 };
  } };
};
var U = function(e2) {
  return void 0 === e2 && (e2 = {}), { name: "shift", options: e2, async fn(t2) {
    const { x: n2, y: r2, placement: o2 } = t2, { mainAxis: i2 = true, crossAxis: l2 = false, limiter: a2 = { fn: (e3) => {
      let { x: t3, y: n3 } = e3;
      return { x: t3, y: n3 };
    } }, ...c2 } = e2, s2 = { x: n2, y: r2 }, u2 = await j(t2, c2), f2 = R(A(o2)), d2 = "x" === f2 ? "y" : "x";
    let p2 = s2[f2], y2 = s2[d2];
    if (i2) {
      const e3 = "y" === f2 ? "bottom" : "right";
      p2 = D(p2 + u2["y" === f2 ? "top" : "left"], p2, p2 - u2[e3]);
    }
    if (l2) {
      const e3 = "y" === d2 ? "bottom" : "right";
      y2 = D(y2 + u2["y" === d2 ? "top" : "left"], y2, y2 - u2[e3]);
    }
    const m2 = a2.fn({ ...t2, [f2]: p2, [d2]: y2 });
    return { ...m2, data: { x: m2.x - n2, y: m2.y - r2 } };
  } };
};
function H(e2) {
  var t2;
  return (null == (t2 = e2.ownerDocument) ? void 0 : t2.defaultView) || window;
}
function B(e2) {
  return H(e2).getComputedStyle(e2);
}
var M = Math.min;
var q = Math.max;
var V = Math.round;
function Y(e2) {
  const t2 = B(e2);
  let n2 = parseFloat(t2.width), r2 = parseFloat(t2.height);
  const o2 = e2.offsetWidth, i2 = e2.offsetHeight, l2 = V(n2) !== o2 || V(r2) !== i2;
  return l2 && (n2 = o2, r2 = i2), { width: n2, height: r2, fallback: l2 };
}
function z(e2) {
  return G(e2) ? (e2.nodeName || "").toLowerCase() : "";
}
var X;
function K() {
  if (X)
    return X;
  const e2 = navigator.userAgentData;
  return e2 && Array.isArray(e2.brands) ? (X = e2.brands.map((e3) => e3.brand + "/" + e3.version).join(" "), X) : navigator.userAgent;
}
function J(e2) {
  return e2 instanceof H(e2).HTMLElement;
}
function Z(e2) {
  return e2 instanceof H(e2).Element;
}
function G(e2) {
  return e2 instanceof H(e2).Node;
}
function Q(e2) {
  if ("undefined" == typeof ShadowRoot)
    return false;
  return e2 instanceof H(e2).ShadowRoot || e2 instanceof ShadowRoot;
}
function ee(e2) {
  const { overflow: t2, overflowX: n2, overflowY: r2, display: o2 } = B(e2);
  return /auto|scroll|overlay|hidden|clip/.test(t2 + r2 + n2) && !["inline", "contents"].includes(o2);
}
function te(e2) {
  return ["table", "td", "th"].includes(z(e2));
}
function ne(e2) {
  const t2 = /firefox/i.test(K()), n2 = B(e2), r2 = n2.backdropFilter || n2.WebkitBackdropFilter;
  return "none" !== n2.transform || "none" !== n2.perspective || !!r2 && "none" !== r2 || t2 && "filter" === n2.willChange || t2 && !!n2.filter && "none" !== n2.filter || ["transform", "perspective"].some((e3) => n2.willChange.includes(e3)) || ["paint", "layout", "strict", "content"].some((e3) => {
    const t3 = n2.contain;
    return null != t3 && t3.includes(e3);
  });
}
function re() {
  return !/^((?!chrome|android).)*safari/i.test(K());
}
function oe(e2) {
  return ["html", "body", "#document"].includes(z(e2));
}
function ie(e2) {
  return Z(e2) ? e2 : e2.contextElement;
}
var le = { x: 1, y: 1 };
function ae(e2) {
  const t2 = ie(e2);
  if (!J(t2))
    return le;
  const n2 = t2.getBoundingClientRect(), { width: r2, height: o2, fallback: i2 } = Y(t2);
  let l2 = (i2 ? V(n2.width) : n2.width) / r2, a2 = (i2 ? V(n2.height) : n2.height) / o2;
  return l2 && Number.isFinite(l2) || (l2 = 1), a2 && Number.isFinite(a2) || (a2 = 1), { x: l2, y: a2 };
}
function ce(e2, t2, n2, r2) {
  var o2, i2;
  void 0 === t2 && (t2 = false), void 0 === n2 && (n2 = false);
  const l2 = e2.getBoundingClientRect(), a2 = ie(e2);
  let c2 = le;
  t2 && (r2 ? Z(r2) && (c2 = ae(r2)) : c2 = ae(e2));
  const s2 = a2 ? H(a2) : window, u2 = !re() && n2;
  let f2 = (l2.left + (u2 && (null == (o2 = s2.visualViewport) ? void 0 : o2.offsetLeft) || 0)) / c2.x, d2 = (l2.top + (u2 && (null == (i2 = s2.visualViewport) ? void 0 : i2.offsetTop) || 0)) / c2.y, p2 = l2.width / c2.x, y2 = l2.height / c2.y;
  if (a2) {
    const e3 = H(a2), t3 = r2 && Z(r2) ? H(r2) : r2;
    let n3 = e3.frameElement;
    for (; n3 && r2 && t3 !== e3; ) {
      const e4 = ae(n3), t4 = n3.getBoundingClientRect(), r3 = getComputedStyle(n3);
      t4.x += (n3.clientLeft + parseFloat(r3.paddingLeft)) * e4.x, t4.y += (n3.clientTop + parseFloat(r3.paddingTop)) * e4.y, f2 *= e4.x, d2 *= e4.y, p2 *= e4.x, y2 *= e4.y, f2 += t4.x, d2 += t4.y, n3 = H(n3).frameElement;
    }
  }
  return { width: p2, height: y2, top: d2, right: f2 + p2, bottom: d2 + y2, left: f2, x: f2, y: d2 };
}
function se(e2) {
  return ((G(e2) ? e2.ownerDocument : e2.document) || window.document).documentElement;
}
function ue(e2) {
  return Z(e2) ? { scrollLeft: e2.scrollLeft, scrollTop: e2.scrollTop } : { scrollLeft: e2.pageXOffset, scrollTop: e2.pageYOffset };
}
function fe(e2) {
  return ce(se(e2)).left + ue(e2).scrollLeft;
}
function de(e2) {
  if ("html" === z(e2))
    return e2;
  const t2 = e2.assignedSlot || e2.parentNode || Q(e2) && e2.host || se(e2);
  return Q(t2) ? t2.host : t2;
}
function pe(e2) {
  const t2 = de(e2);
  return oe(t2) ? t2.ownerDocument.body : J(t2) && ee(t2) ? t2 : pe(t2);
}
function ye(e2, t2) {
  var n2;
  void 0 === t2 && (t2 = []);
  const r2 = pe(e2), o2 = r2 === (null == (n2 = e2.ownerDocument) ? void 0 : n2.body), i2 = H(r2);
  return o2 ? t2.concat(i2, i2.visualViewport || [], ee(r2) ? r2 : []) : t2.concat(r2, ye(r2));
}
function me(e2, t2, n2) {
  return "viewport" === t2 ? E(function(e3, t3) {
    const n3 = H(e3), r2 = se(e3), o2 = n3.visualViewport;
    let i2 = r2.clientWidth, l2 = r2.clientHeight, a2 = 0, c2 = 0;
    if (o2) {
      i2 = o2.width, l2 = o2.height;
      const e4 = re();
      (e4 || !e4 && "fixed" === t3) && (a2 = o2.offsetLeft, c2 = o2.offsetTop);
    }
    return { width: i2, height: l2, x: a2, y: c2 };
  }(e2, n2)) : Z(t2) ? E(function(e3, t3) {
    const n3 = ce(e3, true, "fixed" === t3), r2 = n3.top + e3.clientTop, o2 = n3.left + e3.clientLeft, i2 = J(e3) ? ae(e3) : { x: 1, y: 1 };
    return { width: e3.clientWidth * i2.x, height: e3.clientHeight * i2.y, x: o2 * i2.x, y: r2 * i2.y };
  }(t2, n2)) : E(function(e3) {
    const t3 = se(e3), n3 = ue(e3), r2 = e3.ownerDocument.body, o2 = q(t3.scrollWidth, t3.clientWidth, r2.scrollWidth, r2.clientWidth), i2 = q(t3.scrollHeight, t3.clientHeight, r2.scrollHeight, r2.clientHeight);
    let l2 = -n3.scrollLeft + fe(e3);
    const a2 = -n3.scrollTop;
    return "rtl" === B(r2).direction && (l2 += q(t3.clientWidth, r2.clientWidth) - o2), { width: o2, height: i2, x: l2, y: a2 };
  }(se(e2)));
}
function he(e2) {
  return J(e2) && "fixed" !== B(e2).position ? e2.offsetParent : null;
}
function ge(e2) {
  const t2 = H(e2);
  let n2 = he(e2);
  for (; n2 && te(n2) && "static" === B(n2).position; )
    n2 = he(n2);
  return n2 && ("html" === z(n2) || "body" === z(n2) && "static" === B(n2).position && !ne(n2)) ? t2 : n2 || function(e3) {
    let t3 = de(e3);
    for (; J(t3) && !oe(t3); ) {
      if (ne(t3))
        return t3;
      t3 = de(t3);
    }
    return null;
  }(e2) || t2;
}
function ve(e2, t2, n2) {
  const r2 = J(t2), o2 = se(t2), i2 = ce(e2, true, "fixed" === n2, t2);
  let l2 = { scrollLeft: 0, scrollTop: 0 };
  const a2 = { x: 0, y: 0 };
  if (r2 || !r2 && "fixed" !== n2)
    if (("body" !== z(t2) || ee(o2)) && (l2 = ue(t2)), J(t2)) {
      const e3 = ce(t2, true);
      a2.x = e3.x + t2.clientLeft, a2.y = e3.y + t2.clientTop;
    } else
      o2 && (a2.x = fe(o2));
  return { x: i2.left + l2.scrollLeft - a2.x, y: i2.top + l2.scrollTop - a2.y, width: i2.width, height: i2.height };
}
var we = { getClippingRect: function(e2) {
  let { element: t2, boundary: n2, rootBoundary: r2, strategy: o2 } = e2;
  const i2 = "clippingAncestors" === n2 ? function(e3, t3) {
    const n3 = t3.get(e3);
    if (n3)
      return n3;
    let r3 = ye(e3).filter((e4) => Z(e4) && "body" !== z(e4)), o3 = null;
    const i3 = "fixed" === B(e3).position;
    let l3 = i3 ? de(e3) : e3;
    for (; Z(l3) && !oe(l3); ) {
      const e4 = B(l3), t4 = ne(l3);
      (i3 ? t4 || o3 : t4 || "static" !== e4.position || !o3 || !["absolute", "fixed"].includes(o3.position)) ? o3 = e4 : r3 = r3.filter((e5) => e5 !== l3), l3 = de(l3);
    }
    return t3.set(e3, r3), r3;
  }(t2, this._c) : [].concat(n2), l2 = [...i2, r2], a2 = l2[0], c2 = l2.reduce((e3, n3) => {
    const r3 = me(t2, n3, o2);
    return e3.top = q(r3.top, e3.top), e3.right = M(r3.right, e3.right), e3.bottom = M(r3.bottom, e3.bottom), e3.left = q(r3.left, e3.left), e3;
  }, me(t2, a2, o2));
  return { width: c2.right - c2.left, height: c2.bottom - c2.top, x: c2.left, y: c2.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e2) {
  let { rect: t2, offsetParent: n2, strategy: r2 } = e2;
  const o2 = J(n2), i2 = se(n2);
  if (n2 === i2)
    return t2;
  let l2 = { scrollLeft: 0, scrollTop: 0 }, a2 = { x: 1, y: 1 };
  const c2 = { x: 0, y: 0 };
  if ((o2 || !o2 && "fixed" !== r2) && (("body" !== z(n2) || ee(i2)) && (l2 = ue(n2)), J(n2))) {
    const e3 = ce(n2);
    a2 = ae(n2), c2.x = e3.x + n2.clientLeft, c2.y = e3.y + n2.clientTop;
  }
  return { width: t2.width * a2.x, height: t2.height * a2.y, x: t2.x * a2.x - l2.scrollLeft * a2.x + c2.x, y: t2.y * a2.y - l2.scrollTop * a2.y + c2.y };
}, isElement: Z, getDimensions: function(e2) {
  return J(e2) ? Y(e2) : e2.getBoundingClientRect();
}, getOffsetParent: ge, getDocumentElement: se, getScale: ae, async getElementRects(e2) {
  let { reference: t2, floating: n2, strategy: r2 } = e2;
  const o2 = this.getOffsetParent || ge, i2 = this.getDimensions;
  return { reference: ve(t2, await o2(n2), r2), floating: { x: 0, y: 0, ...await i2(n2) } };
}, getClientRects: (e2) => Array.from(e2.getClientRects()), isRTL: (e2) => "rtl" === B(e2).direction };
var be = (e2, t2, n2) => {
  const r2 = /* @__PURE__ */ new Map(), o2 = { platform: we, ...n2 }, i2 = { ...o2.platform, _c: r2 };
  return (async (e3, t3, n3) => {
    const { placement: r3 = "bottom", strategy: o3 = "absolute", middleware: i3 = [], platform: l2 } = n3, a2 = i3.filter(Boolean), c2 = await (null == l2.isRTL ? void 0 : l2.isRTL(t3));
    if (null == l2 && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), a2.filter((e4) => {
      let { name: t4 } = e4;
      return "autoPlacement" === t4 || "flip" === t4;
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    e3 && t3 || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let s2 = await l2.getElementRects({ reference: e3, floating: t3, strategy: o3 }), { x: u2, y: f2 } = O(s2, r3, c2), d2 = r3, p2 = {}, y2 = 0;
    for (let n4 = 0; n4 < a2.length; n4++) {
      const { name: i4, fn: m2 } = a2[n4], { x: h2, y: g2, data: v2, reset: w2 } = await m2({ x: u2, y: f2, initialPlacement: r3, placement: d2, strategy: o3, middlewareData: p2, rects: s2, platform: l2, elements: { reference: e3, floating: t3 } });
      u2 = null != h2 ? h2 : u2, f2 = null != g2 ? g2 : f2, p2 = { ...p2, [i4]: { ...p2[i4], ...v2 } }, y2 > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), w2 && y2 <= 50 && (y2++, "object" == typeof w2 && (w2.placement && (d2 = w2.placement), w2.rects && (s2 = true === w2.rects ? await l2.getElementRects({ reference: e3, floating: t3, strategy: o3 }) : w2.rects), { x: u2, y: f2 } = O(s2, d2, c2)), n4 = -1);
    }
    return { x: u2, y: f2, placement: d2, strategy: o3, middlewareData: p2 };
  })(e2, t2, { ...o2, platform: i2 });
};
var xe = async ({ elementReference: e2 = null, tooltipReference: t2 = null, tooltipArrowReference: n2 = null, place: r2 = "top", offset: o2 = 10, strategy: i2 = "absolute", middlewares: l2 = [W(Number(o2)), I(), U({ padding: 5 })] }) => {
  if (!e2)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (null === t2)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const a2 = l2;
  return n2 ? (a2.push({ name: "arrow", options: c2 = { element: n2, padding: 5 }, async fn(e3) {
    const { element: t3, padding: n3 = 0 } = c2 || {}, { x: r3, y: o3, placement: i3, rects: l3, platform: a3 } = e3;
    if (null == t3)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const s2 = k(n3), u2 = { x: r3, y: o3 }, f2 = R(i3), d2 = T(f2), p2 = await a3.getDimensions(t3), y2 = "y" === f2 ? "top" : "left", m2 = "y" === f2 ? "bottom" : "right", h2 = l3.reference[d2] + l3.reference[f2] - u2[f2] - l3.floating[d2], g2 = u2[f2] - l3.reference[f2], v2 = await (null == a3.getOffsetParent ? void 0 : a3.getOffsetParent(t3));
    let w2 = v2 ? "y" === f2 ? v2.clientHeight || 0 : v2.clientWidth || 0 : 0;
    0 === w2 && (w2 = l3.floating[d2]);
    const b2 = h2 / 2 - g2 / 2, x2 = s2[y2], _2 = w2 - p2[d2] - s2[m2], A2 = w2 / 2 - p2[d2] / 2 + b2, O2 = D(x2, A2, _2), E2 = null != S(i3) && A2 != O2 && l3.reference[d2] / 2 - (A2 < x2 ? s2[y2] : s2[m2]) - p2[d2] / 2 < 0;
    return { [f2]: u2[f2] - (E2 ? A2 < x2 ? x2 - A2 : _2 - A2 : 0), data: { [f2]: O2, centerOffset: A2 - O2 } };
  } }), be(e2, t2, { placement: r2, strategy: i2, middleware: a2 }).then(({ x: e3, y: t3, placement: n3, middlewareData: r3 }) => {
    var o3, i3;
    const l3 = { left: `${e3}px`, top: `${t3}px` }, { x: a3, y: c3 } = null !== (o3 = r3.arrow) && void 0 !== o3 ? o3 : { x: 0, y: 0 };
    return { tooltipStyles: l3, tooltipArrowStyles: { left: null != a3 ? `${a3}px` : "", top: null != c3 ? `${c3}px` : "", right: "", bottom: "", [null !== (i3 = { top: "bottom", right: "left", bottom: "top", left: "right" }[n3.split("-")[0]]) && void 0 !== i3 ? i3 : "bottom"]: "-4px" } };
  })) : be(e2, t2, { placement: "bottom", strategy: i2, middleware: a2 }).then(({ x: e3, y: t3 }) => ({ tooltipStyles: { left: `${e3}px`, top: `${t3}px` }, tooltipArrowStyles: {} }));
  var c2;
};
var _e = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
var Se = ({ id: e2, className: t2, classNameArrow: r2, variant: o2 = "dark", anchorId: i2, anchorSelect: c2, place: s2 = "top", offset: f2 = 10, events: d2 = ["hover"], positionStrategy: p2 = "absolute", middlewares: g2, wrapper: v2, children: w2 = null, delayShow: x2 = 0, delayHide: S2 = 0, float: T2 = false, noArrow: A2 = false, clickable: R2 = false, closeOnEsc: O2 = false, style: k2, position: E2, afterShow: j2, afterHide: L2, content: P2, html: D2, isOpen: N2, setIsOpen: F2, activeAnchor: $2, setActiveAnchor: C2 }) => {
  const I2 = (0, import_react.useRef)(null), W2 = (0, import_react.useRef)(null), U2 = (0, import_react.useRef)(null), H2 = (0, import_react.useRef)(null), [B2, M2] = (0, import_react.useState)({}), [q2, V2] = (0, import_react.useState)({}), [Y2, z2] = (0, import_react.useState)(false), [X2, K2] = (0, import_react.useState)(false), J2 = (0, import_react.useRef)(false), Z2 = (0, import_react.useRef)(null), { anchorRefs: G2, setActiveAnchor: Q2 } = b(e2), ee2 = (0, import_react.useRef)(false), [te2, ne2] = (0, import_react.useState)([]), re2 = (0, import_react.useRef)(false);
  _(() => (re2.current = true, () => {
    re2.current = false;
  }), []), (0, import_react.useEffect)(() => {
    if (!Y2) {
      const e3 = setTimeout(() => {
        K2(false);
      }, 150);
      return () => {
        clearTimeout(e3);
      };
    }
    return () => null;
  }, [Y2]);
  const oe2 = (e3) => {
    re2.current && (e3 && K2(true), setTimeout(() => {
      re2.current && (null == F2 || F2(e3), void 0 === N2 && z2(e3));
    }, 10));
  };
  (0, import_react.useEffect)(() => {
    if (void 0 === N2)
      return () => null;
    N2 && K2(true);
    const e3 = setTimeout(() => {
      z2(N2);
    }, 10);
    return () => {
      clearTimeout(e3);
    };
  }, [N2]), (0, import_react.useEffect)(() => {
    Y2 !== J2.current && (J2.current = Y2, Y2 ? null == j2 || j2() : null == L2 || L2());
  }, [Y2]);
  const ie2 = (e3 = S2) => {
    H2.current && clearTimeout(H2.current), H2.current = setTimeout(() => {
      ee2.current || oe2(false);
    }, e3);
  }, le2 = (e3) => {
    var t3;
    if (!e3)
      return;
    x2 ? (U2.current && clearTimeout(U2.current), U2.current = setTimeout(() => {
      oe2(true);
    }, x2)) : oe2(true);
    const n2 = null !== (t3 = e3.currentTarget) && void 0 !== t3 ? t3 : e3.target;
    C2(n2), Q2({ current: n2 }), H2.current && clearTimeout(H2.current);
  }, ae2 = () => {
    R2 ? ie2(S2 || 100) : S2 ? ie2() : oe2(false), U2.current && clearTimeout(U2.current);
  }, ce2 = ({ x: e3, y: t3 }) => {
    xe({ place: s2, offset: f2, elementReference: { getBoundingClientRect: () => ({ x: e3, y: t3, width: 0, height: 0, top: t3, left: e3, right: e3, bottom: t3 }) }, tooltipReference: I2.current, tooltipArrowReference: W2.current, strategy: p2, middlewares: g2 }).then((e4) => {
      Object.keys(e4.tooltipStyles).length && M2(e4.tooltipStyles), Object.keys(e4.tooltipArrowStyles).length && V2(e4.tooltipArrowStyles);
    });
  }, se2 = (e3) => {
    if (!e3)
      return;
    const t3 = e3, n2 = { x: t3.clientX, y: t3.clientY };
    ce2(n2), Z2.current = n2;
  }, ue2 = (e3) => {
    le2(e3), S2 && ie2();
  }, fe2 = (e3) => {
    const t3 = document.querySelector(`[id='${i2}']`);
    (null == t3 ? void 0 : t3.contains(e3.target)) || te2.some((t4) => t4.contains(e3.target)) || oe2(false);
  }, de2 = (e3) => {
    "Escape" === e3.key && oe2(false);
  }, pe2 = m(le2, 50), ye2 = m(ae2, 50);
  (0, import_react.useEffect)(() => {
    var e3, t3;
    const n2 = new Set(G2);
    te2.forEach((e4) => {
      n2.add({ current: e4 });
    });
    const r3 = document.querySelector(`[id='${i2}']`);
    r3 && n2.add({ current: r3 }), O2 && window.addEventListener("keydown", de2);
    const o3 = [];
    d2.find((e4) => "click" === e4) && (window.addEventListener("click", fe2), o3.push({ event: "click", listener: ue2 })), d2.find((e4) => "hover" === e4) && (o3.push({ event: "mouseenter", listener: pe2 }, { event: "mouseleave", listener: ye2 }, { event: "focus", listener: pe2 }, { event: "blur", listener: ye2 }), T2 && o3.push({ event: "mousemove", listener: se2 }));
    const l2 = () => {
      ee2.current = true;
    }, a2 = () => {
      ee2.current = false, ae2();
    };
    return R2 && (null === (e3 = I2.current) || void 0 === e3 || e3.addEventListener("mouseenter", l2), null === (t3 = I2.current) || void 0 === t3 || t3.addEventListener("mouseleave", a2)), o3.forEach(({ event: e4, listener: t4 }) => {
      n2.forEach((n3) => {
        var r4;
        null === (r4 = n3.current) || void 0 === r4 || r4.addEventListener(e4, t4);
      });
    }), () => {
      var e4, t4;
      d2.find((e5) => "click" === e5) && window.removeEventListener("click", fe2), O2 && window.removeEventListener("keydown", de2), R2 && (null === (e4 = I2.current) || void 0 === e4 || e4.removeEventListener("mouseenter", l2), null === (t4 = I2.current) || void 0 === t4 || t4.removeEventListener("mouseleave", a2)), o3.forEach(({ event: e5, listener: t5 }) => {
        n2.forEach((n3) => {
          var r4;
          null === (r4 = n3.current) || void 0 === r4 || r4.removeEventListener(e5, t5);
        });
      });
    };
  }, [X2, G2, te2, O2, d2]), (0, import_react.useEffect)(() => {
    let t3 = null != c2 ? c2 : "";
    !t3 && e2 && (t3 = `[data-tooltip-id='${e2}']`);
    const n2 = new MutationObserver((n3) => {
      const r3 = [];
      n3.forEach((n4) => {
        if ("attributes" === n4.type && "data-tooltip-id" === n4.attributeName) {
          n4.target.getAttribute("data-tooltip-id") === e2 && r3.push(n4.target);
        }
        if ("childList" === n4.type && ($2 && [...n4.removedNodes].some((e3) => !!e3.contains($2) && (K2(false), oe2(false), C2(null), true)), t3))
          try {
            const e3 = [...n4.addedNodes].filter((e4) => 1 === e4.nodeType);
            r3.push(...e3.filter((e4) => e4.matches(t3))), r3.push(...e3.flatMap((e4) => [...e4.querySelectorAll(t3)]));
          } catch (e3) {
          }
      }), r3.length && ne2((e3) => [...e3, ...r3]);
    });
    return n2.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ["data-tooltip-id"] }), () => {
      n2.disconnect();
    };
  }, [e2, c2, $2]), (0, import_react.useEffect)(() => {
    E2 ? ce2(E2) : T2 ? Z2.current && ce2(Z2.current) : xe({ place: s2, offset: f2, elementReference: $2, tooltipReference: I2.current, tooltipArrowReference: W2.current, strategy: p2, middlewares: g2 }).then((e3) => {
      re2.current && (Object.keys(e3.tooltipStyles).length && M2(e3.tooltipStyles), Object.keys(e3.tooltipArrowStyles).length && V2(e3.tooltipArrowStyles));
    });
  }, [Y2, $2, P2, D2, s2, f2, p2, E2]), (0, import_react.useEffect)(() => {
    var e3;
    const t3 = document.querySelector(`[id='${i2}']`), n2 = [...te2, t3];
    $2 && n2.includes($2) || C2(null !== (e3 = te2[0]) && void 0 !== e3 ? e3 : t3);
  }, [i2, te2, $2]), (0, import_react.useEffect)(() => () => {
    U2.current && clearTimeout(U2.current), H2.current && clearTimeout(H2.current);
  }, []), (0, import_react.useEffect)(() => {
    let t3 = c2;
    if (!t3 && e2 && (t3 = `[data-tooltip-id='${e2}']`), t3)
      try {
        const e3 = Array.from(document.querySelectorAll(t3));
        ne2(e3);
      } catch (e3) {
        ne2([]);
      }
  }, [e2, c2]);
  const me2 = Boolean(D2 || P2 || w2) && Y2 && Object.keys(B2).length > 0;
  return X2 ? u.exports.jsxs(v2, { id: e2, role: "tooltip", className: y("react-tooltip", _e.tooltip, _e[o2], t2, { [_e.show]: me2, [_e.fixed]: "fixed" === p2, [_e.clickable]: R2 }), style: { ...k2, ...B2 }, ref: I2, children: [D2 && u.exports.jsx(h, { content: D2 }) || P2 || w2, u.exports.jsx(v2, { className: y("react-tooltip-arrow", _e.arrow, r2, { [_e["no-arrow"]]: A2 }), style: q2, ref: W2 })] }) : null;
};
var Te = ({ id: e2, anchorId: t2, anchorSelect: r2, content: o2, html: i2, className: l2, classNameArrow: c2, variant: s2 = "dark", place: f2 = "top", offset: d2 = 10, wrapper: p2 = "div", children: y2 = null, events: m2 = ["hover"], positionStrategy: h2 = "absolute", middlewares: g2, delayShow: v2 = 0, delayHide: w2 = 0, float: x2 = false, noArrow: _2 = false, clickable: S2 = false, closeOnEsc: T2 = false, style: A2, position: R2, isOpen: O2, setIsOpen: k2, afterShow: E2, afterHide: j2 }) => {
  const [L2, P2] = (0, import_react.useState)(o2), [D2, N2] = (0, import_react.useState)(i2), [F2, $2] = (0, import_react.useState)(f2), [C2, I2] = (0, import_react.useState)(s2), [W2, U2] = (0, import_react.useState)(d2), [H2, B2] = (0, import_react.useState)(v2), [M2, q2] = (0, import_react.useState)(w2), [V2, Y2] = (0, import_react.useState)(x2), [z2, X2] = (0, import_react.useState)(p2), [K2, J2] = (0, import_react.useState)(m2), [Z2, G2] = (0, import_react.useState)(h2), [Q2, ee2] = (0, import_react.useState)(null), { anchorRefs: te2, activeAnchor: ne2 } = b(e2), re2 = (e3) => null == e3 ? void 0 : e3.getAttributeNames().reduce((t3, n2) => {
    var r3;
    if (n2.startsWith("data-tooltip-")) {
      t3[n2.replace(/^data-tooltip-/, "")] = null !== (r3 = null == e3 ? void 0 : e3.getAttribute(n2)) && void 0 !== r3 ? r3 : null;
    }
    return t3;
  }, {}), oe2 = (e3) => {
    const t3 = { place: (e4) => {
      var t4;
      $2(null !== (t4 = e4) && void 0 !== t4 ? t4 : f2);
    }, content: (e4) => {
      P2(null != e4 ? e4 : o2);
    }, html: (e4) => {
      N2(null != e4 ? e4 : i2);
    }, variant: (e4) => {
      var t4;
      I2(null !== (t4 = e4) && void 0 !== t4 ? t4 : s2);
    }, offset: (e4) => {
      U2(null === e4 ? d2 : Number(e4));
    }, wrapper: (e4) => {
      var t4;
      X2(null !== (t4 = e4) && void 0 !== t4 ? t4 : p2);
    }, events: (e4) => {
      const t4 = null == e4 ? void 0 : e4.split(" ");
      J2(null != t4 ? t4 : m2);
    }, "position-strategy": (e4) => {
      var t4;
      G2(null !== (t4 = e4) && void 0 !== t4 ? t4 : h2);
    }, "delay-show": (e4) => {
      B2(null === e4 ? v2 : Number(e4));
    }, "delay-hide": (e4) => {
      q2(null === e4 ? w2 : Number(e4));
    }, float: (e4) => {
      Y2(null === e4 ? x2 : "true" === e4);
    } };
    Object.values(t3).forEach((e4) => e4(null)), Object.entries(e3).forEach(([e4, n2]) => {
      var r3;
      null === (r3 = t3[e4]) || void 0 === r3 || r3.call(t3, n2);
    });
  };
  (0, import_react.useEffect)(() => {
    P2(o2);
  }, [o2]), (0, import_react.useEffect)(() => {
    N2(i2);
  }, [i2]), (0, import_react.useEffect)(() => {
    $2(f2);
  }, [f2]), (0, import_react.useEffect)(() => {
    var n2;
    const o3 = new Set(te2);
    let i3 = r2;
    if (!i3 && e2 && (i3 = `[data-tooltip-id='${e2}']`), i3)
      try {
        document.querySelectorAll(i3).forEach((e3) => {
          o3.add({ current: e3 });
        });
      } catch (e3) {
        console.warn(`[react-tooltip] "${r2}" is not a valid CSS selector`);
      }
    const l3 = document.querySelector(`[id='${t2}']`);
    if (l3 && o3.add({ current: l3 }), !o3.size)
      return () => null;
    const a2 = null !== (n2 = null != Q2 ? Q2 : l3) && void 0 !== n2 ? n2 : ne2.current, c3 = new MutationObserver((e3) => {
      e3.forEach((e4) => {
        var t3;
        if (!a2 || "attributes" !== e4.type || !(null === (t3 = e4.attributeName) || void 0 === t3 ? void 0 : t3.startsWith("data-tooltip-")))
          return;
        const n3 = re2(a2);
        oe2(n3);
      });
    }), s3 = { attributes: true, childList: false, subtree: false };
    if (a2) {
      const e3 = re2(a2);
      oe2(e3), c3.observe(a2, s3);
    }
    return () => {
      c3.disconnect();
    };
  }, [te2, ne2, Q2, t2, r2]);
  const ie2 = { id: e2, anchorId: t2, anchorSelect: r2, className: l2, classNameArrow: c2, content: L2, html: D2, place: F2, variant: C2, offset: W2, wrapper: z2, events: K2, positionStrategy: Z2, middlewares: g2, delayShow: H2, delayHide: M2, float: V2, noArrow: _2, clickable: S2, closeOnEsc: T2, style: A2, position: R2, isOpen: O2, setIsOpen: k2, afterShow: E2, afterHide: j2, activeAnchor: Q2, setActiveAnchor: (e3) => ee2(e3) };
  return y2 ? u.exports.jsx(Se, { ...ie2, children: y2 }) : u.exports.jsx(Se, { ...ie2 });
};
export {
  Te as Tooltip,
  w as TooltipProvider,
  x as TooltipWrapper
};
/*! Bundled license information:

react-tooltip/dist/react-tooltip.esm.min.js:
  (** @license React v16.14.0
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=react-tooltip.js.map
