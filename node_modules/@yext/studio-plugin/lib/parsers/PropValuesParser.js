import { SyntaxKind } from "ts-morph";
import { PropValueKind, PropValueType, } from "../types/PropValues";
import StaticParsingHelpers from "../parsers/helpers/StaticParsingHelpers";
import TypeGuards from "../utils/TypeGuards";
/**
 * PropValuesParser is a class for parsing object literals in a Studio file into PropValues.
 */
export default class PropValuesParser {
    studioSourceFileParser;
    constructor(studioSourceFileParser) {
        this.studioSourceFileParser = studioSourceFileParser;
    }
    /**
     * Parses the given exported variable into PropValues.
     * If no variableName is provided, the default export will be parsed
     *
     * @param propShape - Shape of the component's props
     * @param variableName - the variable to parse into PropValues.
     */
    parsePropValues(propShape, variableName) {
        const rawValues = this.getRawValues(variableName);
        if (!rawValues) {
            return undefined;
        }
        return this.parseRawValues(rawValues, propShape);
    }
    getRawValues(variableName) {
        if (variableName) {
            return this.studioSourceFileParser.parseExportedObjectLiteral(variableName);
        }
        const defaultExport = this.studioSourceFileParser.getDefaultExport();
        if (!defaultExport) {
            return undefined;
        }
        if (!defaultExport.isKind(SyntaxKind.ObjectLiteralExpression)) {
            throw new Error(`Expected an ObjectLiteralExpression as the default export in ${this.studioSourceFileParser.getFilepath()}`);
        }
        return StaticParsingHelpers.parseObjectLiteral(defaultExport);
    }
    parseRawValues(rawValues, propShape) {
        const propValues = {};
        const getPropValue = (propName) => {
            const { value } = rawValues[propName];
            if (typeof value === "object") {
                const childShape = propShape[propName];
                if (childShape.type !== PropValueType.Object) {
                    throw new Error(`Expected PropValueType.Object for ${propName} in ${JSON.stringify(propShape, null, 2)}`);
                }
                return {
                    valueType: PropValueType.Object,
                    kind: PropValueKind.Literal,
                    value: this.parseRawValues(value, childShape.shape),
                };
            }
            return {
                valueType: propShape[propName].type,
                kind: PropValueKind.Literal,
                value,
            };
        };
        Object.keys(rawValues).forEach((propName) => {
            const { kind } = rawValues[propName];
            if (kind === PropValueKind.Expression) {
                throw new Error(`Expressions are not supported within object literal.`);
            }
            const propValue = getPropValue(propName);
            TypeGuards.assertIsValidPropVal(propValue);
            propValues[propName] = propValue;
        });
        return propValues;
    }
}
//# sourceMappingURL=PropValuesParser.js.map