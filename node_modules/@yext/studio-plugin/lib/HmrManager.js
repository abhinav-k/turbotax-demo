import { StudioHMRUpdateID } from "./types";
import VirtualModuleID from "./VirtualModuleID";
/**
 * HmrManager is responsible for handling studio specific HMR updates.
 */
export default class HmrManager {
    orchestrator;
    pathToUserProjectRoot;
    userPaths;
    constructor(orchestrator, pathToUserProjectRoot, userPaths) {
        this.orchestrator = orchestrator;
        this.pathToUserProjectRoot = pathToUserProjectRoot;
        this.userPaths = userPaths;
    }
    /**
     * If the file can be recognized as one of the user's src files,
     * update the StudioData and send a custom HMR event to the frontend.
     */
    handleHotUpdate(server, filepath) {
        if (!filepath.startsWith(this.pathToUserProjectRoot)) {
            return;
        }
        this.orchestrator.reloadFile(filepath);
        HmrManager.invalidateStudioData(server);
        const updateType = getHMRUpdateType(filepath, this.userPaths);
        const data = this.getPayload(updateType);
        server.ws.send({
            type: "custom",
            event: StudioHMRUpdateID,
            data,
        });
    }
    /**
     * Tells the client it needs to refresh its StudioData.
     */
    static invalidateStudioData(server) {
        const studioModule = server.moduleGraph.getModuleById("\0" + VirtualModuleID.StudioData);
        if (studioModule) {
            server.moduleGraph.invalidateModule(studioModule);
        }
    }
    getPayload(updateType) {
        const studioData = this.orchestrator.getStudioData();
        return {
            updateType,
            studioData,
        };
    }
}
function getHMRUpdateType(file, userPaths) {
    const updateTypes = [
        "siteSettings",
        "components",
        "modules",
        "pages",
    ];
    return (updateTypes.find((updateType) => {
        return file.startsWith(userPaths[updateType]);
    }) ?? "full");
}
//# sourceMappingURL=HmrManager.js.map